/* tslint:disable */
/* eslint-disable */
/**
 * MedLog REST API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @enum {string}
 */

export const AdministeredByDoctorAnswers = {
    Prescribed: 'prescribed',
    Recommended: 'recommended',
    No: 'no',
    Unknown: 'unknown'
} as const;

export type AdministeredByDoctorAnswers = typeof AdministeredByDoctorAnswers[keyof typeof AdministeredByDoctorAnswers];


/**
 * Datum Außer Handel (JJJJMMTT)
 * @export
 * @interface Ahdatum
 */
export interface Ahdatum {
}
/**
 * This is a metadata table and not part of the official Wido GTK Arzneimittelindex. We track the \"datenstand\" and \"dateiversion\" variants of the source data here.   Args:     DrugModelTableBase (_type_): _description_     table (bool, optional): _description_. Defaults to True.
 * @export
 * @interface AiDataVersion
 */
export interface AiDataVersion {
    /**
     * 
     * @type {string}
     * @memberof AiDataVersion
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof AiDataVersion
     */
    'id'?: string;
    /**
     * Dateiversion
     * @type {string}
     * @memberof AiDataVersion
     */
    'dateiversion': string;
    /**
     * Monat Datenstand (JJJJMM)
     * @type {string}
     * @memberof AiDataVersion
     */
    'datenstand': string;
    /**
     * 
     * @type {ImportCompletedAt}
     * @memberof AiDataVersion
     */
    'import_completed_at'?: ImportCompletedAt;
    /**
     * If set to true this arzneimittel index version will be ignored (when not queried for explciet in the crud interface). This can be helpfull e.g. if the last import contained dirty data and one wants to fallback on the previous version.
     * @type {boolean}
     * @memberof AiDataVersion
     */
    'deactivated'?: boolean;
}
/**
 * 
 * @export
 * @interface ApoPflicht
 */
export interface ApoPflicht {
    /**
     * 
     * @type {string}
     * @memberof ApoPflicht
     */
    'created_at'?: string;
    /**
     * apopflicht id
     * @type {number}
     * @memberof ApoPflicht
     */
    'apopflicht': number;
    /**
     * Bedeutung
     * @type {string}
     * @memberof ApoPflicht
     */
    'bedeutung': string;
}
/**
 * Applikationsformschlüssel (Siehe `appform_ref` für vollen Namen)
 * @export
 * @interface Appform
 */
export interface Appform {
}
/**
 * 
 * @export
 * @interface Applikationsform
 */
export interface Applikationsform {
    /**
     * 
     * @type {string}
     * @memberof Applikationsform
     */
    'created_at'?: string;
    /**
     * Foreing key to \'AiDataVersion\' (\'GKV WiDo Arzneimittel Index\' Data Format Version) which contains the information which Arzneimittel Index \'Datenstand\' and \'Dateiversion\' the row has
     * @type {string}
     * @memberof Applikationsform
     */
    'ai_version_id': string;
    /**
     * Applikationsform
     * @type {string}
     * @memberof Applikationsform
     */
    'appform': string;
    /**
     * Bedeutung
     * @type {string}
     * @memberof Applikationsform
     */
    'bedeutung': string;
}
/**
 * 
 * @export
 * @interface AsNeededDoseUnit
 */
export interface AsNeededDoseUnit {
}
/**
 * ATC-Code (Klassifikation nach WIdO)
 * @export
 * @interface AtcCode
 */
export interface AtcCode {
}
/**
 * 
 * @export
 * @interface Biosimilar
 */
export interface Biosimilar {
    /**
     * 
     * @type {string}
     * @memberof Biosimilar
     */
    'created_at'?: string;
    /**
     * biosimilar id
     * @type {string}
     * @memberof Biosimilar
     */
    'biosimilar': string;
    /**
     * Bedeutung
     * @type {string}
     * @memberof Biosimilar
     */
    'bedeutung': string;
}
/**
 * Gentechnologisch bzw. biotechnologisch hergestellte                 Arzneimittel, zu denen Biosimilars zugelassen und im                 deutschen Markt verfügbar sind oder waren
 * @export
 * @interface Biosimilar1
 */
export interface Biosimilar1 {
}
/**
 * 
 * @export
 * @interface ClientId
 */
export interface ClientId {
}
/**
 * 
 * @export
 * @interface ClientSecret
 */
export interface ClientSecret {
}
/**
 * Is the event completed. E.g. All study participants have been interviewed.
 * @export
 * @interface Completed
 */
export interface Completed {
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ConsumedMedsTodayAnswers = {
    Yes: 'Yes',
    No: 'No',
    Unknown: 'UNKNOWN'
} as const;

export type ConsumedMedsTodayAnswers = typeof ConsumedMedsTodayAnswers[keyof typeof ConsumedMedsTodayAnswers];


/**
 * 
 * @export
 * @interface Darreichungsform
 */
export interface Darreichungsform {
    /**
     * 
     * @type {string}
     * @memberof Darreichungsform
     */
    'created_at'?: string;
    /**
     * Foreing key to \'AiDataVersion\' (\'GKV WiDo Arzneimittel Index\' Data Format Version) which contains the information which Arzneimittel Index \'Datenstand\' and \'Dateiversion\' the row has
     * @type {string}
     * @memberof Darreichungsform
     */
    'ai_version_id': string;
    /**
     * Darreichungsform
     * @type {string}
     * @memberof Darreichungsform
     */
    'darrform': string;
    /**
     * Bedeutung
     * @type {string}
     * @memberof Darreichungsform
     */
    'bedeutung': string;
}
/**
 * 
 * @export
 * @interface DisplayName
 */
export interface DisplayName {
}
/**
 * 
 * @export
 * @interface DisplayName1
 */
export interface DisplayName1 {
}
/**
 * 
 * @export
 * @interface DosePerDay
 */
export interface DosePerDay {
}
/**
 * 
 * @export
 * @interface Email
 */
export interface Email {
}
/**
 * 
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'name'?: string;
    /**
     * 
     * @type {Completed}
     * @memberof Event
     */
    'completed'?: Completed;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'study_id': string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface EventUpdate
 */
export interface EventUpdate {
    /**
     * 
     * @type {Name}
     * @memberof EventUpdate
     */
    'name'?: Name;
    /**
     * 
     * @type {Completed}
     * @memberof EventUpdate
     */
    'completed'?: Completed;
}
/**
 * 
 * @export
 * @interface Generikakennung
 */
export interface Generikakennung {
    /**
     * 
     * @type {string}
     * @memberof Generikakennung
     */
    'created_at'?: string;
    /**
     * generikakenn id
     * @type {number}
     * @memberof Generikakennung
     */
    'generikakenn': number;
    /**
     * Bedeutung
     * @type {string}
     * @memberof Generikakennung
     */
    'bedeutung': string;
}
/**
 * 
 * @export
 * @interface GrantType
 */
export interface GrantType {
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface Hersteller
 */
export interface Hersteller {
    /**
     * 
     * @type {string}
     * @memberof Hersteller
     */
    'created_at'?: string;
    /**
     * Foreing key to \'AiDataVersion\' (\'GKV WiDo Arzneimittel Index\' Data Format Version) which contains the information which Arzneimittel Index \'Datenstand\' and \'Dateiversion\' the row has
     * @type {string}
     * @memberof Hersteller
     */
    'ai_version_id': string;
    /**
     * Hersteller
     * @type {string}
     * @memberof Hersteller
     */
    'herstellercode': string;
    /**
     * Bedeutung
     * @type {string}
     * @memberof Hersteller
     */
    'bedeutung': string;
}
/**
 * 
 * @export
 * @interface Id
 */
export interface Id {
}
/**
 * When starting an import a new AiDataVersion will be made. on completion with no errors this field will be set and the whole Arzneimittelindex is \'armed\'/\'can be used\' 
 * @export
 * @interface ImportCompletedAt
 */
export interface ImportCompletedAt {
}
/**
 * 
 * @export
 * @interface Intake
 */
export interface Intake {
    /**
     * 
     * @type {string}
     * @memberof Intake
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Intake
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Intake
     */
    'interview_id': string;
    /**
     * Pharmazentralnummer as 8 digits only
     * @type {string}
     * @memberof Intake
     */
    'pharmazentralnummer': string;
    /**
     * 
     * @type {string}
     * @memberof Intake
     */
    'intake_start_time_utc': string;
    /**
     * 
     * @type {IntakeEndTimeUtc}
     * @memberof Intake
     */
    'intake_end_time_utc'?: IntakeEndTimeUtc;
    /**
     * 
     * @type {IntakeAdministeredByDoctor}
     * @memberof Intake
     */
    'administered_by_doctor'?: IntakeAdministeredByDoctor;
    /**
     * 
     * @type {IntakeIntakeRegularOrAsNeeded}
     * @memberof Intake
     */
    'intake_regular_or_as_needed'?: IntakeIntakeRegularOrAsNeeded;
    /**
     * 
     * @type {DosePerDay}
     * @memberof Intake
     */
    'dose_per_day'?: DosePerDay;
    /**
     * 
     * @type {IntakeRegularIntervallOfDailyDose}
     * @memberof Intake
     */
    'regular_intervall_of_daily_dose'?: IntakeRegularIntervallOfDailyDose;
    /**
     * 
     * @type {AsNeededDoseUnit}
     * @memberof Intake
     */
    'as_needed_dose_unit': AsNeededDoseUnit;
    /**
     * 
     * @type {ConsumedMedsTodayAnswers}
     * @memberof Intake
     */
    'consumed_meds_today': ConsumedMedsTodayAnswers;
}


/**
 * 
 * @export
 * @interface IntakeAdministeredByDoctor
 */
export interface IntakeAdministeredByDoctor {
}
/**
 * This class/table also saves some extra question for every interview. This is 1-to-1 what the old IDOM software did. and its a mess. i fucking hate it. its unflexible, complex and ugly! for a future version we need an extra class/table to store extra question on a per study base. fields (with meatdata like options) could be defined in json schema. so clients can generate dynamic forms relatively easy.
 * @export
 * @interface IntakeCreate
 */
export interface IntakeCreate {
    /**
     * 
     * @type {Id}
     * @memberof IntakeCreate
     */
    'id': Id;
    /**
     * 
     * @type {InterviewId}
     * @memberof IntakeCreate
     */
    'interview_id': InterviewId;
    /**
     * Take the Pharmazentralnummer in many formats, but all formats will be normalized to just a 8 digit number.
     * @type {string}
     * @memberof IntakeCreate
     */
    'pharmazentralnummer': string;
    /**
     * 
     * @type {string}
     * @memberof IntakeCreate
     */
    'intake_start_time_utc': string;
    /**
     * 
     * @type {IntakeEndTimeUtc}
     * @memberof IntakeCreate
     */
    'intake_end_time_utc'?: IntakeEndTimeUtc;
    /**
     * 
     * @type {IntakeAdministeredByDoctor}
     * @memberof IntakeCreate
     */
    'administered_by_doctor'?: IntakeAdministeredByDoctor;
    /**
     * 
     * @type {IntakeIntakeRegularOrAsNeeded}
     * @memberof IntakeCreate
     */
    'intake_regular_or_as_needed'?: IntakeIntakeRegularOrAsNeeded;
    /**
     * 
     * @type {DosePerDay}
     * @memberof IntakeCreate
     */
    'dose_per_day'?: DosePerDay;
    /**
     * 
     * @type {IntakeRegularIntervallOfDailyDose}
     * @memberof IntakeCreate
     */
    'regular_intervall_of_daily_dose'?: IntakeRegularIntervallOfDailyDose;
    /**
     * 
     * @type {AsNeededDoseUnit}
     * @memberof IntakeCreate
     */
    'as_needed_dose_unit': AsNeededDoseUnit;
    /**
     * 
     * @type {ConsumedMedsTodayAnswers}
     * @memberof IntakeCreate
     */
    'consumed_meds_today': ConsumedMedsTodayAnswers;
}


/**
 * 
 * @export
 * @interface IntakeEndTimeUtc
 */
export interface IntakeEndTimeUtc {
}
/**
 * If a med is taken regualr or as needed. When choosen regular the field `regular_intervall_of_daily_dose` is mandatory and `as_needed_dose_unit` must be `None`/`null`. When the choosen `as needed` the oposite is true. This is the old IDOM behaviour, its ugly, i hate it and it will change in a futue version
 * @export
 * @interface IntakeIntakeRegularOrAsNeeded
 */
export interface IntakeIntakeRegularOrAsNeeded {
}
/**
 * 
 * @export
 * @interface IntakeRegularIntervallOfDailyDose
 */
export interface IntakeRegularIntervallOfDailyDose {
}
/**
 * 
 * @export
 * @enum {string}
 */

export const IntakeRegularOrAsNeededAnswers = {
    Regular: 'regular',
    AsNeeded: 'as needed'
} as const;

export type IntakeRegularOrAsNeededAnswers = typeof IntakeRegularOrAsNeededAnswers[keyof typeof IntakeRegularOrAsNeededAnswers];


/**
 * 
 * @export
 * @interface IntakeUpdate
 */
export interface IntakeUpdate {
    /**
     * 
     * @type {Id}
     * @memberof IntakeUpdate
     */
    'id': Id;
    /**
     * 
     * @type {InterviewId}
     * @memberof IntakeUpdate
     */
    'interview_id': InterviewId;
    /**
     * Take the Pharmazentralnummer in many formats, but all formats will be normalized to just a 8 digit number.
     * @type {string}
     * @memberof IntakeUpdate
     */
    'pharmazentralnummer': string;
    /**
     * 
     * @type {string}
     * @memberof IntakeUpdate
     */
    'intake_start_time_utc': string;
    /**
     * 
     * @type {IntakeEndTimeUtc}
     * @memberof IntakeUpdate
     */
    'intake_end_time_utc'?: IntakeEndTimeUtc;
    /**
     * 
     * @type {IntakeAdministeredByDoctor}
     * @memberof IntakeUpdate
     */
    'administered_by_doctor'?: IntakeAdministeredByDoctor;
    /**
     * 
     * @type {IntakeIntakeRegularOrAsNeeded}
     * @memberof IntakeUpdate
     */
    'intake_regular_or_as_needed'?: IntakeIntakeRegularOrAsNeeded;
    /**
     * 
     * @type {DosePerDay}
     * @memberof IntakeUpdate
     */
    'dose_per_day'?: DosePerDay;
    /**
     * 
     * @type {IntakeRegularIntervallOfDailyDose}
     * @memberof IntakeUpdate
     */
    'regular_intervall_of_daily_dose'?: IntakeRegularIntervallOfDailyDose;
    /**
     * 
     * @type {AsNeededDoseUnit}
     * @memberof IntakeUpdate
     */
    'as_needed_dose_unit': AsNeededDoseUnit;
    /**
     * 
     * @type {ConsumedMedsTodayAnswers}
     * @memberof IntakeUpdate
     */
    'consumed_meds_today': ConsumedMedsTodayAnswers;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const IntervalOfDailyDoseAnswers = {
    Regular: 'regular',
    AsNeeded: 'as needed',
    Every2Day: 'every 2. day',
    Every3Day: 'every 3. day',
    Every4DayTwiceAWeek: 'every 4. day / twice a week',
    IntervalsOfOneWeekOrMore: 'intervals of one week or more'
} as const;

export type IntervalOfDailyDoseAnswers = typeof IntervalOfDailyDoseAnswers[keyof typeof IntervalOfDailyDoseAnswers];


/**
 * 
 * @export
 * @interface Interview
 */
export interface Interview {
    /**
     * 
     * @type {string}
     * @memberof Interview
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Interview
     */
    'event_id': string;
    /**
     * A unique ID given to the proband from the studies external probant management system
     * @type {string}
     * @memberof Interview
     */
    'proband_external_id': string;
    /**
     * 
     * @type {string}
     * @memberof Interview
     */
    'interview_start_time_utc'?: string;
    /**
     * 
     * @type {string}
     * @memberof Interview
     */
    'interview_end_time_utc'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Interview
     */
    'proband_has_taken_meds': boolean;
    /**
     * TB: This field is still kind of mysterious to me. In the user interview video the user just filled it with some number. Maybe a process we can automize (shameless plug: https://git.apps.dzd-ev.org/dzdpythonmodules/ptan)?
     * @type {number}
     * @memberof Interview
     */
    'interview_number': number;
    /**
     * 
     * @type {string}
     * @memberof Interview
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface InterviewCreate
 */
export interface InterviewCreate {
    /**
     * 
     * @type {string}
     * @memberof InterviewCreate
     */
    'event_id': string;
    /**
     * A unique ID given to the proband from the studies external probant management system
     * @type {string}
     * @memberof InterviewCreate
     */
    'proband_external_id': string;
    /**
     * 
     * @type {string}
     * @memberof InterviewCreate
     */
    'interview_start_time_utc'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterviewCreate
     */
    'interview_end_time_utc'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InterviewCreate
     */
    'proband_has_taken_meds': boolean;
    /**
     * TB: This field is still kind of mysterious to me. In the user interview video the user just filled it with some number. Maybe a process we can automize (shameless plug: https://git.apps.dzd-ev.org/dzdpythonmodules/ptan)?
     * @type {number}
     * @memberof InterviewCreate
     */
    'interview_number': number;
}
/**
 * 
 * @export
 * @interface InterviewId
 */
export interface InterviewId {
}
/**
 * 
 * @export
 * @interface InterviewUpdate
 */
export interface InterviewUpdate {
    /**
     * 
     * @type {string}
     * @memberof InterviewUpdate
     */
    'event_id': string;
    /**
     * A unique ID given to the proband from the studies external probant management system
     * @type {string}
     * @memberof InterviewUpdate
     */
    'proband_external_id': string;
    /**
     * 
     * @type {string}
     * @memberof InterviewUpdate
     */
    'interview_start_time_utc'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterviewUpdate
     */
    'interview_end_time_utc'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InterviewUpdate
     */
    'proband_has_taken_meds': boolean;
    /**
     * TB: This field is still kind of mysterious to me. In the user interview video the user just filled it with some number. Maybe a process we can automize (shameless plug: https://git.apps.dzd-ev.org/dzdpythonmodules/ptan)?
     * @type {number}
     * @memberof InterviewUpdate
     */
    'interview_number': number;
}
/**
 * 
 * @export
 * @interface JWTAccessTokenResponse
 */
export interface JWTAccessTokenResponse {
    /**
     * 
     * @type {any}
     * @memberof JWTAccessTokenResponse
     */
    'token_type'?: any;
    /**
     * The number of seconds until the token expires
     * @type {number}
     * @memberof JWTAccessTokenResponse
     */
    'expires_in': number;
    /**
     * The time as POSIX timestamp in UTC when the token expires
     * @type {number}
     * @memberof JWTAccessTokenResponse
     */
    'expires_at': number;
    /**
     * Token to be used to authenticate against the API
     * @type {string}
     * @memberof JWTAccessTokenResponse
     */
    'access_token': string;
}
/**
 * 
 * @export
 * @interface JWTBundleTokenResponse
 */
export interface JWTBundleTokenResponse {
    /**
     * 
     * @type {any}
     * @memberof JWTBundleTokenResponse
     */
    'token_type'?: any;
    /**
     * The number of seconds until the token expires
     * @type {number}
     * @memberof JWTBundleTokenResponse
     */
    'expires_in': number;
    /**
     * The time as POSIX timestamp in UTC when the token expires
     * @type {number}
     * @memberof JWTBundleTokenResponse
     */
    'expires_at': number;
    /**
     * Refresh token to be used to get new access tokens
     * @type {string}
     * @memberof JWTBundleTokenResponse
     */
    'refresh_token': string;
    /**
     * Token to be used to authenticate against the API
     * @type {string}
     * @memberof JWTBundleTokenResponse
     */
    'access_token': string;
    /**
     * The number of seconds until the token expires
     * @type {number}
     * @memberof JWTBundleTokenResponse
     */
    'refresh_token_expires_in': number;
    /**
     * 
     * @type {number}
     * @memberof JWTBundleTokenResponse
     */
    'refresh_token_expires_at': number;
}
/**
 * Datum Marktzugang (JJJJMMTT)
 * @export
 * @interface Marktzugang
 */
export interface Marktzugang {
}
/**
 * 
 * @export
 * @interface MedLogSearchEngineResult
 */
export interface MedLogSearchEngineResult {
    /**
     * 
     * @type {string}
     * @memberof MedLogSearchEngineResult
     */
    'pzn': string;
    /**
     * 
     * @type {number}
     * @memberof MedLogSearchEngineResult
     */
    'relevance_score': number;
    /**
     * 
     * @type {StammRead}
     * @memberof MedLogSearchEngineResult
     */
    'item': StammRead;
}
/**
 * 
 * @export
 * @interface Name
 */
export interface Name {
}
/**
 * 
 * @export
 * @interface Normpackungsgroessen
 */
export interface Normpackungsgroessen {
    /**
     * 
     * @type {string}
     * @memberof Normpackungsgroessen
     */
    'created_at'?: string;
    /**
     * Foreing key to \'AiDataVersion\' (\'GKV WiDo Arzneimittel Index\' Data Format Version) which contains the information which Arzneimittel Index \'Datenstand\' and \'Dateiversion\' the row has
     * @type {string}
     * @memberof Normpackungsgroessen
     */
    'ai_version_id': string;
    /**
     * Normpackungsgröße. Tim: I dont know where the term \'zuzahlstufe\' is coming from. It does not make too much sense for me and its confusing compared to the table name `Normpackungsgroessen`. Maybe historic artefact/bug in the Arzneimittelindex or i am just stupid.
     * @type {string}
     * @memberof Normpackungsgroessen
     */
    'zuzahlstufe': string;
    /**
     * Bedeutung
     * @type {string}
     * @memberof Normpackungsgroessen
     */
    'bedeutung': string;
}
/**
 * 
 * @export
 * @interface PaginatedResponseApoPflicht
 */
export interface PaginatedResponseApoPflicht {
    /**
     * 
     * @type {TotalCount}
     * @memberof PaginatedResponseApoPflicht
     */
    'total_count'?: TotalCount;
    /**
     * Starting position index of the returned items in the dataset.
     * @type {number}
     * @memberof PaginatedResponseApoPflicht
     */
    'offset': number;
    /**
     * Number of items returned in the response
     * @type {number}
     * @memberof PaginatedResponseApoPflicht
     */
    'count': number;
    /**
     * List of items returned in the response following given criteria
     * @type {Array<ApoPflicht>}
     * @memberof PaginatedResponseApoPflicht
     */
    'items': Array<ApoPflicht>;
}
/**
 * 
 * @export
 * @interface PaginatedResponseApplikationsform
 */
export interface PaginatedResponseApplikationsform {
    /**
     * 
     * @type {TotalCount}
     * @memberof PaginatedResponseApplikationsform
     */
    'total_count'?: TotalCount;
    /**
     * Starting position index of the returned items in the dataset.
     * @type {number}
     * @memberof PaginatedResponseApplikationsform
     */
    'offset': number;
    /**
     * Number of items returned in the response
     * @type {number}
     * @memberof PaginatedResponseApplikationsform
     */
    'count': number;
    /**
     * List of items returned in the response following given criteria
     * @type {Array<Applikationsform>}
     * @memberof PaginatedResponseApplikationsform
     */
    'items': Array<Applikationsform>;
}
/**
 * 
 * @export
 * @interface PaginatedResponseDarreichungsform
 */
export interface PaginatedResponseDarreichungsform {
    /**
     * 
     * @type {TotalCount}
     * @memberof PaginatedResponseDarreichungsform
     */
    'total_count'?: TotalCount;
    /**
     * Starting position index of the returned items in the dataset.
     * @type {number}
     * @memberof PaginatedResponseDarreichungsform
     */
    'offset': number;
    /**
     * Number of items returned in the response
     * @type {number}
     * @memberof PaginatedResponseDarreichungsform
     */
    'count': number;
    /**
     * List of items returned in the response following given criteria
     * @type {Array<Darreichungsform>}
     * @memberof PaginatedResponseDarreichungsform
     */
    'items': Array<Darreichungsform>;
}
/**
 * 
 * @export
 * @interface PaginatedResponseEvent
 */
export interface PaginatedResponseEvent {
    /**
     * 
     * @type {TotalCount}
     * @memberof PaginatedResponseEvent
     */
    'total_count'?: TotalCount;
    /**
     * Starting position index of the returned items in the dataset.
     * @type {number}
     * @memberof PaginatedResponseEvent
     */
    'offset': number;
    /**
     * Number of items returned in the response
     * @type {number}
     * @memberof PaginatedResponseEvent
     */
    'count': number;
    /**
     * List of items returned in the response following given criteria
     * @type {Array<Event>}
     * @memberof PaginatedResponseEvent
     */
    'items': Array<Event>;
}
/**
 * 
 * @export
 * @interface PaginatedResponseGenerikakennung
 */
export interface PaginatedResponseGenerikakennung {
    /**
     * 
     * @type {TotalCount}
     * @memberof PaginatedResponseGenerikakennung
     */
    'total_count'?: TotalCount;
    /**
     * Starting position index of the returned items in the dataset.
     * @type {number}
     * @memberof PaginatedResponseGenerikakennung
     */
    'offset': number;
    /**
     * Number of items returned in the response
     * @type {number}
     * @memberof PaginatedResponseGenerikakennung
     */
    'count': number;
    /**
     * List of items returned in the response following given criteria
     * @type {Array<Generikakennung>}
     * @memberof PaginatedResponseGenerikakennung
     */
    'items': Array<Generikakennung>;
}
/**
 * 
 * @export
 * @interface PaginatedResponseMedLogSearchEngineResult
 */
export interface PaginatedResponseMedLogSearchEngineResult {
    /**
     * 
     * @type {TotalCount}
     * @memberof PaginatedResponseMedLogSearchEngineResult
     */
    'total_count'?: TotalCount;
    /**
     * Starting position index of the returned items in the dataset.
     * @type {number}
     * @memberof PaginatedResponseMedLogSearchEngineResult
     */
    'offset': number;
    /**
     * Number of items returned in the response
     * @type {number}
     * @memberof PaginatedResponseMedLogSearchEngineResult
     */
    'count': number;
    /**
     * List of items returned in the response following given criteria
     * @type {Array<MedLogSearchEngineResult>}
     * @memberof PaginatedResponseMedLogSearchEngineResult
     */
    'items': Array<MedLogSearchEngineResult>;
}
/**
 * 
 * @export
 * @interface PaginatedResponseNormpackungsgroessen
 */
export interface PaginatedResponseNormpackungsgroessen {
    /**
     * 
     * @type {TotalCount}
     * @memberof PaginatedResponseNormpackungsgroessen
     */
    'total_count'?: TotalCount;
    /**
     * Starting position index of the returned items in the dataset.
     * @type {number}
     * @memberof PaginatedResponseNormpackungsgroessen
     */
    'offset': number;
    /**
     * Number of items returned in the response
     * @type {number}
     * @memberof PaginatedResponseNormpackungsgroessen
     */
    'count': number;
    /**
     * List of items returned in the response following given criteria
     * @type {Array<Normpackungsgroessen>}
     * @memberof PaginatedResponseNormpackungsgroessen
     */
    'items': Array<Normpackungsgroessen>;
}
/**
 * 
 * @export
 * @interface PaginatedResponsePreisart
 */
export interface PaginatedResponsePreisart {
    /**
     * 
     * @type {TotalCount}
     * @memberof PaginatedResponsePreisart
     */
    'total_count'?: TotalCount;
    /**
     * Starting position index of the returned items in the dataset.
     * @type {number}
     * @memberof PaginatedResponsePreisart
     */
    'offset': number;
    /**
     * Number of items returned in the response
     * @type {number}
     * @memberof PaginatedResponsePreisart
     */
    'count': number;
    /**
     * List of items returned in the response following given criteria
     * @type {Array<Preisart>}
     * @memberof PaginatedResponsePreisart
     */
    'items': Array<Preisart>;
}
/**
 * 
 * @export
 * @interface PaginatedResponseStammRead
 */
export interface PaginatedResponseStammRead {
    /**
     * 
     * @type {TotalCount}
     * @memberof PaginatedResponseStammRead
     */
    'total_count'?: TotalCount;
    /**
     * Starting position index of the returned items in the dataset.
     * @type {number}
     * @memberof PaginatedResponseStammRead
     */
    'offset': number;
    /**
     * Number of items returned in the response
     * @type {number}
     * @memberof PaginatedResponseStammRead
     */
    'count': number;
    /**
     * List of items returned in the response following given criteria
     * @type {Array<StammRead>}
     * @memberof PaginatedResponseStammRead
     */
    'items': Array<StammRead>;
}
/**
 * 
 * @export
 * @interface PaginatedResponseStudy
 */
export interface PaginatedResponseStudy {
    /**
     * 
     * @type {TotalCount}
     * @memberof PaginatedResponseStudy
     */
    'total_count'?: TotalCount;
    /**
     * Starting position index of the returned items in the dataset.
     * @type {number}
     * @memberof PaginatedResponseStudy
     */
    'offset': number;
    /**
     * Number of items returned in the response
     * @type {number}
     * @memberof PaginatedResponseStudy
     */
    'count': number;
    /**
     * List of items returned in the response following given criteria
     * @type {Array<Study>}
     * @memberof PaginatedResponseStudy
     */
    'items': Array<Study>;
}
/**
 * 
 * @export
 * @interface PaginatedResponseStudyPermissionRead
 */
export interface PaginatedResponseStudyPermissionRead {
    /**
     * 
     * @type {TotalCount}
     * @memberof PaginatedResponseStudyPermissionRead
     */
    'total_count'?: TotalCount;
    /**
     * Starting position index of the returned items in the dataset.
     * @type {number}
     * @memberof PaginatedResponseStudyPermissionRead
     */
    'offset': number;
    /**
     * Number of items returned in the response
     * @type {number}
     * @memberof PaginatedResponseStudyPermissionRead
     */
    'count': number;
    /**
     * List of items returned in the response following given criteria
     * @type {Array<StudyPermissionRead>}
     * @memberof PaginatedResponseStudyPermissionRead
     */
    'items': Array<StudyPermissionRead>;
}
/**
 * 
 * @export
 * @interface PaginatedResponseUser
 */
export interface PaginatedResponseUser {
    /**
     * 
     * @type {TotalCount}
     * @memberof PaginatedResponseUser
     */
    'total_count'?: TotalCount;
    /**
     * Starting position index of the returned items in the dataset.
     * @type {number}
     * @memberof PaginatedResponseUser
     */
    'offset': number;
    /**
     * Number of items returned in the response
     * @type {number}
     * @memberof PaginatedResponseUser
     */
    'count': number;
    /**
     * List of items returned in the response following given criteria
     * @type {Array<User>}
     * @memberof PaginatedResponseUser
     */
    'items': Array<User>;
}
/**
 * 
 * @export
 * @interface Preisart
 */
export interface Preisart {
    /**
     * 
     * @type {string}
     * @memberof Preisart
     */
    'created_at'?: string;
    /**
     * preiart id
     * @type {string}
     * @memberof Preisart
     */
    'preisart': string;
    /**
     * Bedeutung
     * @type {string}
     * @memberof Preisart
     */
    'bedeutung': string;
}
/**
 * Preisart, alt schlüssel  (Siehe `preisart_alt_ref` für vollen Namen)
 * @export
 * @interface PreisartAlt
 */
export interface PreisartAlt {
}
/**
 * Preisart, neu schlüssel  (Siehe `preisart_neu_ref` für vollen Namen)
 * @export
 * @interface PreisartNeu
 */
export interface PreisartNeu {
}
/**
 * (Sämtliche Arzneimittel eines Handelsnamens)Standardaggregatkennung (zu Lfd. Nr.)
 * @export
 * @interface Stakenn
 */
export interface Stakenn {
}
/**
 * 
 * @export
 * @interface StammRead
 */
export interface StammRead {
    /**
     * 
     * @type {string}
     * @memberof StammRead
     */
    'created_at'?: string;
    /**
     * Foreing key to \'AiDataVersion\' (\'GKV WiDo Arzneimittel Index\' Data Format Version) which contains the information which Arzneimittel Index \'Datenstand\' and \'Dateiversion\' the row has
     * @type {string}
     * @memberof StammRead
     */
    'ai_version_id': string;
    /**
     * Laufende Nummer (vom WIdO vergeben)
     * @type {string}
     * @memberof StammRead
     */
    'laufnr': string;
    /**
     * 
     * @type {Stakenn}
     * @memberof StammRead
     */
    'stakenn': Stakenn;
    /**
     * Standardaggregatname (vom WIdO vergeben) (enhält *NV* wenn \'Noch nicht abschließend klassifiziertes Arzneimittel\')
     * @type {string}
     * @memberof StammRead
     */
    'staname': string;
    /**
     * 
     * @type {AtcCode}
     * @memberof StammRead
     */
    'atc_code': AtcCode;
    /**
     * Indikationsgruppe (nach Roter Liste 2014)
     * @type {string}
     * @memberof StammRead
     */
    'indgr': string;
    /**
     * Pharmazentralnummer
     * @type {string}
     * @memberof StammRead
     */
    'pzn': string;
    /**
     * Präparatename
     * @type {string}
     * @memberof StammRead
     */
    'name': string;
    /**
     * Herstellerschlüssel (Siehe `hersteller_ref` für vollen Herstellernamen)
     * @type {string}
     * @memberof StammRead
     */
    'hersteller_code': string;
    /**
     * Darreichungsformschlüssel (Siehe `darrform_ref` für vollen Namen)
     * @type {string}
     * @memberof StammRead
     */
    'darrform': string;
    /**
     * 
     * @type {Zuzahlstufe}
     * @memberof StammRead
     */
    'zuzahlstufe': Zuzahlstufe;
    /**
     * Packungsgröße (in 1/10 Einheiten)
     * @type {number}
     * @memberof StammRead
     */
    'packgroesse': number;
    /**
     * DDD je Packung (nach WIdO, in 1/1000 Einheiten)
     * @type {string}
     * @memberof StammRead
     */
    'dddpk': string;
    /**
     * Apotheken-/Rezeptpflichtschlüssel (Siehe `apopflicht_ref` für vollen Namen)
     * @type {number}
     * @memberof StammRead
     */
    'apopflicht': number;
    /**
     * 
     * @type {PreisartAlt}
     * @memberof StammRead
     */
    'preisart_alt': PreisartAlt;
    /**
     * 
     * @type {PreisartNeu}
     * @memberof StammRead
     */
    'preisart_neu': PreisartNeu;
    /**
     * Preis alt (in Cent)
     * @type {number}
     * @memberof StammRead
     */
    'preis_alt': number;
    /**
     * Preis neu (in Cent)
     * @type {number}
     * @memberof StammRead
     */
    'preis_neu': number;
    /**
     * Festbetrag (in Cent)
     * @type {number}
     * @memberof StammRead
     */
    'festbetrag': number;
    /**
     * 
     * @type {Marktzugang}
     * @memberof StammRead
     */
    'marktzugang': Marktzugang;
    /**
     * 
     * @type {Ahdatum}
     * @memberof StammRead
     */
    'ahdatum': Ahdatum;
    /**
     * Rückruf/zurückgezogen oder zurückgezogen durch Hersteller
     * @type {boolean}
     * @memberof StammRead
     */
    'rueckruf': boolean;
    /**
     * Generika-Kennung
     * @type {number}
     * @memberof StammRead
     */
    'generikakenn': number;
    /**
     * 
     * @type {Appform}
     * @memberof StammRead
     */
    'appform': Appform;
    /**
     * 
     * @type {Biosimilar1}
     * @memberof StammRead
     */
    'biosimilar': Biosimilar1;
    /**
     * Von der EMA mit Orphan Drug Status zugelassene Arzneimittel (Klassifikation zum Stichtag)
     * @type {boolean}
     * @memberof StammRead
     */
    'orphan': boolean;
    /**
     * 
     * @type {AiDataVersion}
     * @memberof StammRead
     */
    'ai_version_ref': AiDataVersion;
    /**
     * 
     * @type {Darreichungsform}
     * @memberof StammRead
     */
    'darrform_ref': Darreichungsform;
    /**
     * 
     * @type {StammReadAppformRef}
     * @memberof StammRead
     */
    'appform_ref': StammReadAppformRef;
    /**
     * 
     * @type {StammReadZuzahlstufeRef}
     * @memberof StammRead
     */
    'zuzahlstufe_ref': StammReadZuzahlstufeRef;
    /**
     * 
     * @type {Hersteller}
     * @memberof StammRead
     */
    'hersteller_ref': Hersteller;
    /**
     * 
     * @type {ApoPflicht}
     * @memberof StammRead
     */
    'apopflicht_ref': ApoPflicht;
    /**
     * 
     * @type {StammReadPreisartNeuRef}
     * @memberof StammRead
     */
    'preisart_neu_ref': StammReadPreisartNeuRef;
    /**
     * 
     * @type {StammReadPreisartNeuRef}
     * @memberof StammRead
     */
    'preisart_alt_ref': StammReadPreisartNeuRef;
    /**
     * 
     * @type {StammReadBiosimilarRef}
     * @memberof StammRead
     */
    'biosimilar_ref': StammReadBiosimilarRef;
    /**
     * 
     * @type {Generikakennung}
     * @memberof StammRead
     */
    'generikakenn_ref': Generikakennung;
}
/**
 * 
 * @export
 * @interface StammReadAppformRef
 */
export interface StammReadAppformRef {
    /**
     * 
     * @type {any}
     * @memberof StammReadAppformRef
     */
    'created_at'?: any;
    /**
     * Foreing key to \'AiDataVersion\' (\'GKV WiDo Arzneimittel Index\' Data Format Version) which contains the information which Arzneimittel Index \'Datenstand\' and \'Dateiversion\' the row has
     * @type {any}
     * @memberof StammReadAppformRef
     */
    'ai_version_id': any;
    /**
     * Applikationsform
     * @type {any}
     * @memberof StammReadAppformRef
     */
    'appform': any;
    /**
     * Bedeutung
     * @type {any}
     * @memberof StammReadAppformRef
     */
    'bedeutung': any;
}
/**
 * 
 * @export
 * @interface StammReadBiosimilarRef
 */
export interface StammReadBiosimilarRef {
    /**
     * 
     * @type {any}
     * @memberof StammReadBiosimilarRef
     */
    'created_at'?: any;
    /**
     * biosimilar id
     * @type {any}
     * @memberof StammReadBiosimilarRef
     */
    'biosimilar': any;
    /**
     * Bedeutung
     * @type {any}
     * @memberof StammReadBiosimilarRef
     */
    'bedeutung': any;
}
/**
 * 
 * @export
 * @interface StammReadPreisartNeuRef
 */
export interface StammReadPreisartNeuRef {
    /**
     * 
     * @type {any}
     * @memberof StammReadPreisartNeuRef
     */
    'created_at'?: any;
    /**
     * preiart id
     * @type {any}
     * @memberof StammReadPreisartNeuRef
     */
    'preisart': any;
    /**
     * Bedeutung
     * @type {any}
     * @memberof StammReadPreisartNeuRef
     */
    'bedeutung': any;
}
/**
 * 
 * @export
 * @interface StammReadZuzahlstufeRef
 */
export interface StammReadZuzahlstufeRef {
    /**
     * 
     * @type {any}
     * @memberof StammReadZuzahlstufeRef
     */
    'created_at'?: any;
    /**
     * Foreing key to \'AiDataVersion\' (\'GKV WiDo Arzneimittel Index\' Data Format Version) which contains the information which Arzneimittel Index \'Datenstand\' and \'Dateiversion\' the row has
     * @type {any}
     * @memberof StammReadZuzahlstufeRef
     */
    'ai_version_id': any;
    /**
     * Normpackungsgröße. Tim: I dont know where the term \'zuzahlstufe\' is coming from. It does not make too much sense for me and its confusing compared to the table name `Normpackungsgroessen`. Maybe historic artefact/bug in the Arzneimittelindex or i am just stupid.
     * @type {any}
     * @memberof StammReadZuzahlstufeRef
     */
    'zuzahlstufe': any;
    /**
     * Bedeutung
     * @type {any}
     * @memberof StammReadZuzahlstufeRef
     */
    'bedeutung': any;
}
/**
 * 
 * @export
 * @interface Study
 */
export interface Study {
    /**
     * 
     * @type {string}
     * @memberof Study
     */
    'created_at'?: string;
    /**
     * 
     * @type {DisplayName}
     * @memberof Study
     */
    'display_name'?: DisplayName;
    /**
     * 
     * @type {boolean}
     * @memberof Study
     */
    'deactivated'?: boolean;
    /**
     * If this is set to True all user have access as interviewers to the study. This can be utile when this MedLog instance only host one study.  Admin access still need to be allocated explicit.
     * @type {boolean}
     * @memberof Study
     */
    'no_permissions'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Study
     */
    'id'?: string;
    /**
     * The identifiying name of the study. This can not be changed later. Must be a \'[Slug](https://en.wikipedia.org/wiki/Clean_URL#Slug)\'; A human and machine reable string containing no spaces, only numbers, lowered latin-script-letters and dashes. If you need to change the name later, use the display name.
     * @type {string}
     * @memberof Study
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface StudyCreate
 */
export interface StudyCreate {
    /**
     * 
     * @type {DisplayName}
     * @memberof StudyCreate
     */
    'display_name'?: DisplayName;
    /**
     * 
     * @type {boolean}
     * @memberof StudyCreate
     */
    'deactivated'?: boolean;
    /**
     * If this is set to True all user have access as interviewers to the study. This can be utile when this MedLog instance only host one study.  Admin access still need to be allocated explicit.
     * @type {boolean}
     * @memberof StudyCreate
     */
    'no_permissions'?: boolean;
    /**
     * 
     * @type {Id}
     * @memberof StudyCreate
     */
    'id': Id;
    /**
     * The identifiying name of the study. This can not be changed later. Must be a \'[Slug](https://en.wikipedia.org/wiki/Clean_URL#Slug)\'; A human and machine reable string containing no spaces, only numbers, lowered latin-script-letters and dashes. If you need to change the name later, use the display name.
     * @type {string}
     * @memberof StudyCreate
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface StudyId
 */
export interface StudyId {
}
/**
 * 
 * @export
 * @interface StudyPermissionRead
 */
export interface StudyPermissionRead {
    /**
     * This is the minimal access to a study. The user can see all data but can not alter anything
     * @type {boolean}
     * @memberof StudyPermissionRead
     */
    'is_study_viewer'?: boolean;
    /**
     * Study interviewers can create new interview entries for this study.
     * @type {boolean}
     * @memberof StudyPermissionRead
     */
    'is_study_interviewer'?: boolean;
    /**
     * Study admins can give access to the study to new users.
     * @type {boolean}
     * @memberof StudyPermissionRead
     */
    'is_study_admin'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StudyPermissionRead
     */
    'study_id': string;
    /**
     * 
     * @type {string}
     * @memberof StudyPermissionRead
     */
    'user_id': string;
    /**
     * 
     * @type {string}
     * @memberof StudyPermissionRead
     */
    'id': string;
    /**
     * 
     * @type {User}
     * @memberof StudyPermissionRead
     */
    'user_ref': User;
    /**
     * 
     * @type {Study}
     * @memberof StudyPermissionRead
     */
    'study_ref': Study;
}
/**
 * 
 * @export
 * @interface StudyPermisson
 */
export interface StudyPermisson {
    /**
     * 
     * @type {string}
     * @memberof StudyPermisson
     */
    'created_at'?: string;
    /**
     * This is the minimal access to a study. The user can see all data but can not alter anything
     * @type {boolean}
     * @memberof StudyPermisson
     */
    'is_study_viewer'?: boolean;
    /**
     * Study interviewers can create new interview entries for this study.
     * @type {boolean}
     * @memberof StudyPermisson
     */
    'is_study_interviewer'?: boolean;
    /**
     * Study admins can give access to the study to new users.
     * @type {boolean}
     * @memberof StudyPermisson
     */
    'is_study_admin'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StudyPermisson
     */
    'study_id': string;
    /**
     * 
     * @type {string}
     * @memberof StudyPermisson
     */
    'user_id': string;
    /**
     * 
     * @type {string}
     * @memberof StudyPermisson
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface StudyPermissonUpdate
 */
export interface StudyPermissonUpdate {
    /**
     * This is the minimal access to a study. The user can see all data but can not alter anything
     * @type {boolean}
     * @memberof StudyPermissonUpdate
     */
    'is_study_viewer'?: boolean;
    /**
     * Study interviewers can create new interview entries for this study.
     * @type {boolean}
     * @memberof StudyPermissonUpdate
     */
    'is_study_interviewer'?: boolean;
    /**
     * Study admins can give access to the study to new users.
     * @type {boolean}
     * @memberof StudyPermissonUpdate
     */
    'is_study_admin'?: boolean;
}
/**
 * 
 * @export
 * @interface StudyUpdate
 */
export interface StudyUpdate {
    /**
     * 
     * @type {DisplayName}
     * @memberof StudyUpdate
     */
    'display_name'?: DisplayName;
    /**
     * 
     * @type {boolean}
     * @memberof StudyUpdate
     */
    'deactivated'?: boolean;
    /**
     * If this is set to True all user have access as interviewers to the study. This can be utile when this MedLog instance only host one study.  Admin access still need to be allocated explicit.
     * @type {boolean}
     * @memberof StudyUpdate
     */
    'no_permissions'?: boolean;
}
/**
 * Total number of items in the database
 * @export
 * @interface TotalCount
 */
export interface TotalCount {
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'created_at'?: string;
    /**
     * 
     * @type {Email}
     * @memberof User
     */
    'email'?: Email;
    /**
     * 
     * @type {DisplayName1}
     * @memberof User
     */
    'display_name'?: DisplayName1;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof User
     */
    'roles'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'deactivated'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'is_email_verified'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'user_name'?: string;
}
/**
 * 
 * @export
 * @interface UserCreate
 */
export interface UserCreate {
    /**
     * 
     * @type {Email}
     * @memberof UserCreate
     */
    'email'?: Email;
    /**
     * 
     * @type {DisplayName1}
     * @memberof UserCreate
     */
    'display_name'?: DisplayName1;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'user_name'?: string;
    /**
     * 
     * @type {Id}
     * @memberof UserCreate
     */
    'id': Id;
}
/**
 * 
 * @export
 * @interface UserUpdateByAdmin
 */
export interface UserUpdateByAdmin {
    /**
     * 
     * @type {Email}
     * @memberof UserUpdateByAdmin
     */
    'email'?: Email;
    /**
     * 
     * @type {DisplayName1}
     * @memberof UserUpdateByAdmin
     */
    'display_name'?: DisplayName1;
    /**
     * 
     * @type {Id}
     * @memberof UserUpdateByAdmin
     */
    'id'?: Id;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserUpdateByAdmin
     */
    'roles'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof UserUpdateByAdmin
     */
    'deactivated'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserUpdateByAdmin
     */
    'is_email_verified'?: boolean;
}
/**
 * 
 * @export
 * @interface UserUpdateByUser
 */
export interface UserUpdateByUser {
    /**
     * 
     * @type {Email}
     * @memberof UserUpdateByUser
     */
    'email'?: Email;
    /**
     * 
     * @type {DisplayName1}
     * @memberof UserUpdateByUser
     */
    'display_name'?: DisplayName1;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<ValidationErrorLocInner>}
     * @memberof ValidationError
     */
    'loc': Array<ValidationErrorLocInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ValidationErrorLocInner
 */
export interface ValidationErrorLocInner {
}
/**
 * Normpackungsgrößenschlüssel (Siehe `zuzahlstufe_ref` für vollen Namen)
 * @export
 * @interface Zuzahlstufe
 */
export interface Zuzahlstufe {
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Endpoint to get a new/fresh access token. A valid refresh token must be provided. Accepts the refresh token either as a form field **OR** in the \'refresh-token\' header field.<br>Returns a new access token on success.
         * @summary Get Fresh Access Token
         * @param {string} [refreshToken] Refresh token via &#x60;refresh-token&#x60; header field
         * @param {string} [refreshTokenForm] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFreshAccessTokenAuthRefreshPost: async (refreshToken?: string, refreshTokenForm?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            if (refreshToken != null) {
                localVarHeaderParameter['refresh-token'] = String(refreshToken);
            }


            if (refreshTokenForm !== undefined) { 
                localVarFormParams.set('refresh_token_form', refreshTokenForm as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login For Refresh And Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {GrantType} [grantType] 
         * @param {string} [scope] 
         * @param {ClientId} [clientId] 
         * @param {ClientSecret} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginForRefreshAndAccessTokenAuthTokenPost: async (username: string, password: string, grantType?: GrantType, scope?: string, clientId?: ClientId, clientSecret?: ClientSecret, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('loginForRefreshAndAccessTokenAuthTokenPost', 'username', username)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('loginForRefreshAndAccessTokenAuthTokenPost', 'password', password)
            const localVarPath = `/auth/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (grantType !== undefined) { 
                localVarFormParams.set('grant_type', grantType as any);
            }
    
            if (username !== undefined) { 
                localVarFormParams.set('username', username as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.set('password', password as any);
            }
    
            if (scope !== undefined) { 
                localVarFormParams.set('scope', scope as any);
            }
    
            if (clientId !== undefined) { 
                localVarFormParams.set('client_id', clientId as any);
            }
    
            if (clientSecret !== undefined) { 
                localVarFormParams.set('client_secret', clientSecret as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Endpoint to get a new/fresh access token. A valid refresh token must be provided. Accepts the refresh token either as a form field **OR** in the \'refresh-token\' header field.<br>Returns a new access token on success.
         * @summary Get Fresh Access Token
         * @param {string} [refreshToken] Refresh token via &#x60;refresh-token&#x60; header field
         * @param {string} [refreshTokenForm] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFreshAccessTokenAuthRefreshPost(refreshToken?: string, refreshTokenForm?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JWTAccessTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFreshAccessTokenAuthRefreshPost(refreshToken, refreshTokenForm, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.getFreshAccessTokenAuthRefreshPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Login For Refresh And Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {GrantType} [grantType] 
         * @param {string} [scope] 
         * @param {ClientId} [clientId] 
         * @param {ClientSecret} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginForRefreshAndAccessTokenAuthTokenPost(username: string, password: string, grantType?: GrantType, scope?: string, clientId?: ClientId, clientSecret?: ClientSecret, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JWTBundleTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginForRefreshAndAccessTokenAuthTokenPost(username, password, grantType, scope, clientId, clientSecret, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.loginForRefreshAndAccessTokenAuthTokenPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Endpoint to get a new/fresh access token. A valid refresh token must be provided. Accepts the refresh token either as a form field **OR** in the \'refresh-token\' header field.<br>Returns a new access token on success.
         * @summary Get Fresh Access Token
         * @param {string} [refreshToken] Refresh token via &#x60;refresh-token&#x60; header field
         * @param {string} [refreshTokenForm] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFreshAccessTokenAuthRefreshPost(refreshToken?: string, refreshTokenForm?: string, options?: any): AxiosPromise<JWTAccessTokenResponse> {
            return localVarFp.getFreshAccessTokenAuthRefreshPost(refreshToken, refreshTokenForm, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login For Refresh And Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {GrantType} [grantType] 
         * @param {string} [scope] 
         * @param {ClientId} [clientId] 
         * @param {ClientSecret} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginForRefreshAndAccessTokenAuthTokenPost(username: string, password: string, grantType?: GrantType, scope?: string, clientId?: ClientId, clientSecret?: ClientSecret, options?: any): AxiosPromise<JWTBundleTokenResponse> {
            return localVarFp.loginForRefreshAndAccessTokenAuthTokenPost(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Endpoint to get a new/fresh access token. A valid refresh token must be provided. Accepts the refresh token either as a form field **OR** in the \'refresh-token\' header field.<br>Returns a new access token on success.
     * @summary Get Fresh Access Token
     * @param {string} [refreshToken] Refresh token via &#x60;refresh-token&#x60; header field
     * @param {string} [refreshTokenForm] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getFreshAccessTokenAuthRefreshPost(refreshToken?: string, refreshTokenForm?: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).getFreshAccessTokenAuthRefreshPost(refreshToken, refreshTokenForm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login For Refresh And Access Token
     * @param {string} username 
     * @param {string} password 
     * @param {GrantType} [grantType] 
     * @param {string} [scope] 
     * @param {ClientId} [clientId] 
     * @param {ClientSecret} [clientSecret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public loginForRefreshAndAccessTokenAuthTokenPost(username: string, password: string, grantType?: GrantType, scope?: string, clientId?: ClientId, clientSecret?: ClientSecret, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).loginForRefreshAndAccessTokenAuthTokenPost(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DrugApi - axios parameter creator
 * @export
 */
export const DrugApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a drugs data by its PZN
         * @summary Get Drug
         * @param {string} pzn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDrugDrugByPznPznGet: async (pzn: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pzn' is not null or undefined
            assertParamExists('getDrugDrugByPznPznGet', 'pzn', pzn)
            const localVarPath = `/drug/by-pzn/{pzn}`
                .replace(`{${"pzn"}}`, encodeURIComponent(String(pzn)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * list ApoPflicht
         * @summary List Apopflicht
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [orderBy] 
         * @param {boolean} [orderDesc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApopflichtDrugEnumApopflichtGet: async (offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/drug/enum/apopflicht`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderDesc !== undefined) {
                localVarQueryParameter['order_desc'] = orderDesc;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * list Preisart
         * @summary List Apopflicht
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [orderBy] 
         * @param {boolean} [orderDesc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApopflichtDrugEnumPreisartGet: async (offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/drug/enum/preisart`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderDesc !== undefined) {
                localVarQueryParameter['order_desc'] = orderDesc;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * list Applikationsform
         * @summary List Applikationsforms
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [orderBy] 
         * @param {boolean} [orderDesc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplikationsformsDrugEnumAppformGet: async (offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/drug/enum/appform`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderDesc !== undefined) {
                localVarQueryParameter['order_desc'] = orderDesc;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * list Applikationsform
         * @summary List Applikationsforms
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplikationsformsDrugEnumAppformKeyGet: async (key: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('listApplikationsformsDrugEnumAppformKeyGet', 'key', key)
            const localVarPath = `/drug/enum/appform/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * list ...
         * @summary List Darreichungsforms
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [orderBy] 
         * @param {boolean} [orderDesc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDarreichungsformsDrugEnumDarrformGet: async (offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/drug/enum/darrform`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderDesc !== undefined) {
                localVarQueryParameter['order_desc'] = orderDesc;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all medicine/drugs from the system. Needs admin role.
         * @summary List Drugs
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [orderBy] 
         * @param {boolean} [orderDesc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDrugsDrugGet: async (offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/drug`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderDesc !== undefined) {
                localVarQueryParameter['order_desc'] = orderDesc;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * list Generikakennung
         * @summary List Generikakenns
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [orderBy] 
         * @param {boolean} [orderDesc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGenerikakennsDrugEnumGenerikakennGet: async (offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/drug/enum/generikakenn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderDesc !== undefined) {
                localVarQueryParameter['order_desc'] = orderDesc;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * list normpackungsgroessen
         * @summary List Packgroesse
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [orderBy] 
         * @param {boolean} [orderDesc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPackgroesseDrugEnumNormpackungsgroessenGet: async (offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/drug/enum/normpackungsgroessen`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderDesc !== undefined) {
                localVarQueryParameter['order_desc'] = orderDesc;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search medicine/drugs from the system
         * @summary Search Drugs
         * @param {string} searchTerm A search term. Can be multiple words or a single one. One word must be at least 3 chars or contained in a longer quoted string (e.g. &#x60;\&#39;Salofalk 1 g\&#39;&#x60; instead of &#x60;Salofalk 1 g&#x60;)
         * @param {string} [pznContains] 
         * @param {string} [filterPackgroesse] 
         * @param {string} [filterDarrform] 
         * @param {string} [filterAppform] 
         * @param {string} [filterNormpackungsgroeeZuzahlstufe] 
         * @param {string} [filterAtcLevel2] 
         * @param {string} [filterGenerikakenn] 
         * @param {number} [filterApopflicht] 
         * @param {string} [filterPreisartNeu] 
         * @param {boolean} [onlyCurrentMedications] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [orderBy] 
         * @param {boolean} [orderDesc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDrugsDrugSearchGet: async (searchTerm: string, pznContains?: string, filterPackgroesse?: string, filterDarrform?: string, filterAppform?: string, filterNormpackungsgroeeZuzahlstufe?: string, filterAtcLevel2?: string, filterGenerikakenn?: string, filterApopflicht?: number, filterPreisartNeu?: string, onlyCurrentMedications?: boolean, offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchTerm' is not null or undefined
            assertParamExists('searchDrugsDrugSearchGet', 'searchTerm', searchTerm)
            const localVarPath = `/drug/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (searchTerm !== undefined) {
                localVarQueryParameter['search_term'] = searchTerm;
            }

            if (pznContains !== undefined) {
                localVarQueryParameter['pzn_contains'] = pznContains;
            }

            if (filterPackgroesse !== undefined) {
                localVarQueryParameter['filter_packgroesse'] = filterPackgroesse;
            }

            if (filterDarrform !== undefined) {
                localVarQueryParameter['filter_darrform'] = filterDarrform;
            }

            if (filterAppform !== undefined) {
                localVarQueryParameter['filter_appform'] = filterAppform;
            }

            if (filterNormpackungsgroeeZuzahlstufe !== undefined) {
                localVarQueryParameter['filter_normpackungsgroeße_zuzahlstufe'] = filterNormpackungsgroeeZuzahlstufe;
            }

            if (filterAtcLevel2 !== undefined) {
                localVarQueryParameter['filter_atc_level2'] = filterAtcLevel2;
            }

            if (filterGenerikakenn !== undefined) {
                localVarQueryParameter['filter_generikakenn'] = filterGenerikakenn;
            }

            if (filterApopflicht !== undefined) {
                localVarQueryParameter['filter_apopflicht'] = filterApopflicht;
            }

            if (filterPreisartNeu !== undefined) {
                localVarQueryParameter['filter_preisart_neu'] = filterPreisartNeu;
            }

            if (onlyCurrentMedications !== undefined) {
                localVarQueryParameter['only_current_medications'] = onlyCurrentMedications;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderDesc !== undefined) {
                localVarQueryParameter['order_desc'] = orderDesc;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DrugApi - functional programming interface
 * @export
 */
export const DrugApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DrugApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a drugs data by its PZN
         * @summary Get Drug
         * @param {string} pzn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDrugDrugByPznPznGet(pzn: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StammRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDrugDrugByPznPznGet(pzn, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrugApi.getDrugDrugByPznPznGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * list ApoPflicht
         * @summary List Apopflicht
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [orderBy] 
         * @param {boolean} [orderDesc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApopflichtDrugEnumApopflichtGet(offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseApoPflicht>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApopflichtDrugEnumApopflichtGet(offset, limit, orderBy, orderDesc, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrugApi.listApopflichtDrugEnumApopflichtGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * list Preisart
         * @summary List Apopflicht
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [orderBy] 
         * @param {boolean} [orderDesc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApopflichtDrugEnumPreisartGet(offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponsePreisart>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApopflichtDrugEnumPreisartGet(offset, limit, orderBy, orderDesc, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrugApi.listApopflichtDrugEnumPreisartGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * list Applikationsform
         * @summary List Applikationsforms
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [orderBy] 
         * @param {boolean} [orderDesc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplikationsformsDrugEnumAppformGet(offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseApplikationsform>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplikationsformsDrugEnumAppformGet(offset, limit, orderBy, orderDesc, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrugApi.listApplikationsformsDrugEnumAppformGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * list Applikationsform
         * @summary List Applikationsforms
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplikationsformsDrugEnumAppformKeyGet(key: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Applikationsform>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplikationsformsDrugEnumAppformKeyGet(key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrugApi.listApplikationsformsDrugEnumAppformKeyGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * list ...
         * @summary List Darreichungsforms
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [orderBy] 
         * @param {boolean} [orderDesc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDarreichungsformsDrugEnumDarrformGet(offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseDarreichungsform>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDarreichungsformsDrugEnumDarrformGet(offset, limit, orderBy, orderDesc, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrugApi.listDarreichungsformsDrugEnumDarrformGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all medicine/drugs from the system. Needs admin role.
         * @summary List Drugs
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [orderBy] 
         * @param {boolean} [orderDesc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDrugsDrugGet(offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseStammRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDrugsDrugGet(offset, limit, orderBy, orderDesc, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrugApi.listDrugsDrugGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * list Generikakennung
         * @summary List Generikakenns
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [orderBy] 
         * @param {boolean} [orderDesc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGenerikakennsDrugEnumGenerikakennGet(offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseGenerikakennung>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGenerikakennsDrugEnumGenerikakennGet(offset, limit, orderBy, orderDesc, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrugApi.listGenerikakennsDrugEnumGenerikakennGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * list normpackungsgroessen
         * @summary List Packgroesse
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [orderBy] 
         * @param {boolean} [orderDesc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPackgroesseDrugEnumNormpackungsgroessenGet(offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseNormpackungsgroessen>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPackgroesseDrugEnumNormpackungsgroessenGet(offset, limit, orderBy, orderDesc, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrugApi.listPackgroesseDrugEnumNormpackungsgroessenGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search medicine/drugs from the system
         * @summary Search Drugs
         * @param {string} searchTerm A search term. Can be multiple words or a single one. One word must be at least 3 chars or contained in a longer quoted string (e.g. &#x60;\&#39;Salofalk 1 g\&#39;&#x60; instead of &#x60;Salofalk 1 g&#x60;)
         * @param {string} [pznContains] 
         * @param {string} [filterPackgroesse] 
         * @param {string} [filterDarrform] 
         * @param {string} [filterAppform] 
         * @param {string} [filterNormpackungsgroeeZuzahlstufe] 
         * @param {string} [filterAtcLevel2] 
         * @param {string} [filterGenerikakenn] 
         * @param {number} [filterApopflicht] 
         * @param {string} [filterPreisartNeu] 
         * @param {boolean} [onlyCurrentMedications] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [orderBy] 
         * @param {boolean} [orderDesc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchDrugsDrugSearchGet(searchTerm: string, pznContains?: string, filterPackgroesse?: string, filterDarrform?: string, filterAppform?: string, filterNormpackungsgroeeZuzahlstufe?: string, filterAtcLevel2?: string, filterGenerikakenn?: string, filterApopflicht?: number, filterPreisartNeu?: string, onlyCurrentMedications?: boolean, offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseMedLogSearchEngineResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchDrugsDrugSearchGet(searchTerm, pznContains, filterPackgroesse, filterDarrform, filterAppform, filterNormpackungsgroeeZuzahlstufe, filterAtcLevel2, filterGenerikakenn, filterApopflicht, filterPreisartNeu, onlyCurrentMedications, offset, limit, orderBy, orderDesc, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrugApi.searchDrugsDrugSearchGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DrugApi - factory interface
 * @export
 */
export const DrugApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DrugApiFp(configuration)
    return {
        /**
         * Get a drugs data by its PZN
         * @summary Get Drug
         * @param {string} pzn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDrugDrugByPznPznGet(pzn: string, options?: any): AxiosPromise<StammRead> {
            return localVarFp.getDrugDrugByPznPznGet(pzn, options).then((request) => request(axios, basePath));
        },
        /**
         * list ApoPflicht
         * @summary List Apopflicht
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [orderBy] 
         * @param {boolean} [orderDesc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApopflichtDrugEnumApopflichtGet(offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options?: any): AxiosPromise<PaginatedResponseApoPflicht> {
            return localVarFp.listApopflichtDrugEnumApopflichtGet(offset, limit, orderBy, orderDesc, options).then((request) => request(axios, basePath));
        },
        /**
         * list Preisart
         * @summary List Apopflicht
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [orderBy] 
         * @param {boolean} [orderDesc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApopflichtDrugEnumPreisartGet(offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options?: any): AxiosPromise<PaginatedResponsePreisart> {
            return localVarFp.listApopflichtDrugEnumPreisartGet(offset, limit, orderBy, orderDesc, options).then((request) => request(axios, basePath));
        },
        /**
         * list Applikationsform
         * @summary List Applikationsforms
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [orderBy] 
         * @param {boolean} [orderDesc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplikationsformsDrugEnumAppformGet(offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options?: any): AxiosPromise<PaginatedResponseApplikationsform> {
            return localVarFp.listApplikationsformsDrugEnumAppformGet(offset, limit, orderBy, orderDesc, options).then((request) => request(axios, basePath));
        },
        /**
         * list Applikationsform
         * @summary List Applikationsforms
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplikationsformsDrugEnumAppformKeyGet(key: string, options?: any): AxiosPromise<Applikationsform> {
            return localVarFp.listApplikationsformsDrugEnumAppformKeyGet(key, options).then((request) => request(axios, basePath));
        },
        /**
         * list ...
         * @summary List Darreichungsforms
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [orderBy] 
         * @param {boolean} [orderDesc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDarreichungsformsDrugEnumDarrformGet(offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options?: any): AxiosPromise<PaginatedResponseDarreichungsform> {
            return localVarFp.listDarreichungsformsDrugEnumDarrformGet(offset, limit, orderBy, orderDesc, options).then((request) => request(axios, basePath));
        },
        /**
         * List all medicine/drugs from the system. Needs admin role.
         * @summary List Drugs
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [orderBy] 
         * @param {boolean} [orderDesc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDrugsDrugGet(offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options?: any): AxiosPromise<PaginatedResponseStammRead> {
            return localVarFp.listDrugsDrugGet(offset, limit, orderBy, orderDesc, options).then((request) => request(axios, basePath));
        },
        /**
         * list Generikakennung
         * @summary List Generikakenns
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [orderBy] 
         * @param {boolean} [orderDesc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGenerikakennsDrugEnumGenerikakennGet(offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options?: any): AxiosPromise<PaginatedResponseGenerikakennung> {
            return localVarFp.listGenerikakennsDrugEnumGenerikakennGet(offset, limit, orderBy, orderDesc, options).then((request) => request(axios, basePath));
        },
        /**
         * list normpackungsgroessen
         * @summary List Packgroesse
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [orderBy] 
         * @param {boolean} [orderDesc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPackgroesseDrugEnumNormpackungsgroessenGet(offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options?: any): AxiosPromise<PaginatedResponseNormpackungsgroessen> {
            return localVarFp.listPackgroesseDrugEnumNormpackungsgroessenGet(offset, limit, orderBy, orderDesc, options).then((request) => request(axios, basePath));
        },
        /**
         * Search medicine/drugs from the system
         * @summary Search Drugs
         * @param {string} searchTerm A search term. Can be multiple words or a single one. One word must be at least 3 chars or contained in a longer quoted string (e.g. &#x60;\&#39;Salofalk 1 g\&#39;&#x60; instead of &#x60;Salofalk 1 g&#x60;)
         * @param {string} [pznContains] 
         * @param {string} [filterPackgroesse] 
         * @param {string} [filterDarrform] 
         * @param {string} [filterAppform] 
         * @param {string} [filterNormpackungsgroeeZuzahlstufe] 
         * @param {string} [filterAtcLevel2] 
         * @param {string} [filterGenerikakenn] 
         * @param {number} [filterApopflicht] 
         * @param {string} [filterPreisartNeu] 
         * @param {boolean} [onlyCurrentMedications] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [orderBy] 
         * @param {boolean} [orderDesc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDrugsDrugSearchGet(searchTerm: string, pznContains?: string, filterPackgroesse?: string, filterDarrform?: string, filterAppform?: string, filterNormpackungsgroeeZuzahlstufe?: string, filterAtcLevel2?: string, filterGenerikakenn?: string, filterApopflicht?: number, filterPreisartNeu?: string, onlyCurrentMedications?: boolean, offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options?: any): AxiosPromise<PaginatedResponseMedLogSearchEngineResult> {
            return localVarFp.searchDrugsDrugSearchGet(searchTerm, pznContains, filterPackgroesse, filterDarrform, filterAppform, filterNormpackungsgroeeZuzahlstufe, filterAtcLevel2, filterGenerikakenn, filterApopflicht, filterPreisartNeu, onlyCurrentMedications, offset, limit, orderBy, orderDesc, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DrugApi - object-oriented interface
 * @export
 * @class DrugApi
 * @extends {BaseAPI}
 */
export class DrugApi extends BaseAPI {
    /**
     * Get a drugs data by its PZN
     * @summary Get Drug
     * @param {string} pzn 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrugApi
     */
    public getDrugDrugByPznPznGet(pzn: string, options?: RawAxiosRequestConfig) {
        return DrugApiFp(this.configuration).getDrugDrugByPznPznGet(pzn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * list ApoPflicht
     * @summary List Apopflicht
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {string} [orderBy] 
     * @param {boolean} [orderDesc] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrugApi
     */
    public listApopflichtDrugEnumApopflichtGet(offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options?: RawAxiosRequestConfig) {
        return DrugApiFp(this.configuration).listApopflichtDrugEnumApopflichtGet(offset, limit, orderBy, orderDesc, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * list Preisart
     * @summary List Apopflicht
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {string} [orderBy] 
     * @param {boolean} [orderDesc] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrugApi
     */
    public listApopflichtDrugEnumPreisartGet(offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options?: RawAxiosRequestConfig) {
        return DrugApiFp(this.configuration).listApopflichtDrugEnumPreisartGet(offset, limit, orderBy, orderDesc, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * list Applikationsform
     * @summary List Applikationsforms
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {string} [orderBy] 
     * @param {boolean} [orderDesc] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrugApi
     */
    public listApplikationsformsDrugEnumAppformGet(offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options?: RawAxiosRequestConfig) {
        return DrugApiFp(this.configuration).listApplikationsformsDrugEnumAppformGet(offset, limit, orderBy, orderDesc, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * list Applikationsform
     * @summary List Applikationsforms
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrugApi
     */
    public listApplikationsformsDrugEnumAppformKeyGet(key: string, options?: RawAxiosRequestConfig) {
        return DrugApiFp(this.configuration).listApplikationsformsDrugEnumAppformKeyGet(key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * list ...
     * @summary List Darreichungsforms
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {string} [orderBy] 
     * @param {boolean} [orderDesc] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrugApi
     */
    public listDarreichungsformsDrugEnumDarrformGet(offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options?: RawAxiosRequestConfig) {
        return DrugApiFp(this.configuration).listDarreichungsformsDrugEnumDarrformGet(offset, limit, orderBy, orderDesc, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all medicine/drugs from the system. Needs admin role.
     * @summary List Drugs
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {string} [orderBy] 
     * @param {boolean} [orderDesc] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrugApi
     */
    public listDrugsDrugGet(offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options?: RawAxiosRequestConfig) {
        return DrugApiFp(this.configuration).listDrugsDrugGet(offset, limit, orderBy, orderDesc, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * list Generikakennung
     * @summary List Generikakenns
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {string} [orderBy] 
     * @param {boolean} [orderDesc] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrugApi
     */
    public listGenerikakennsDrugEnumGenerikakennGet(offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options?: RawAxiosRequestConfig) {
        return DrugApiFp(this.configuration).listGenerikakennsDrugEnumGenerikakennGet(offset, limit, orderBy, orderDesc, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * list normpackungsgroessen
     * @summary List Packgroesse
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {string} [orderBy] 
     * @param {boolean} [orderDesc] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrugApi
     */
    public listPackgroesseDrugEnumNormpackungsgroessenGet(offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options?: RawAxiosRequestConfig) {
        return DrugApiFp(this.configuration).listPackgroesseDrugEnumNormpackungsgroessenGet(offset, limit, orderBy, orderDesc, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search medicine/drugs from the system
     * @summary Search Drugs
     * @param {string} searchTerm A search term. Can be multiple words or a single one. One word must be at least 3 chars or contained in a longer quoted string (e.g. &#x60;\&#39;Salofalk 1 g\&#39;&#x60; instead of &#x60;Salofalk 1 g&#x60;)
     * @param {string} [pznContains] 
     * @param {string} [filterPackgroesse] 
     * @param {string} [filterDarrform] 
     * @param {string} [filterAppform] 
     * @param {string} [filterNormpackungsgroeeZuzahlstufe] 
     * @param {string} [filterAtcLevel2] 
     * @param {string} [filterGenerikakenn] 
     * @param {number} [filterApopflicht] 
     * @param {string} [filterPreisartNeu] 
     * @param {boolean} [onlyCurrentMedications] 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {string} [orderBy] 
     * @param {boolean} [orderDesc] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrugApi
     */
    public searchDrugsDrugSearchGet(searchTerm: string, pznContains?: string, filterPackgroesse?: string, filterDarrform?: string, filterAppform?: string, filterNormpackungsgroeeZuzahlstufe?: string, filterAtcLevel2?: string, filterGenerikakenn?: string, filterApopflicht?: number, filterPreisartNeu?: string, onlyCurrentMedications?: boolean, offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options?: RawAxiosRequestConfig) {
        return DrugApiFp(this.configuration).searchDrugsDrugSearchGet(searchTerm, pznContains, filterPackgroesse, filterDarrform, filterAppform, filterNormpackungsgroeeZuzahlstufe, filterAtcLevel2, filterGenerikakenn, filterApopflicht, filterPreisartNeu, onlyCurrentMedications, offset, limit, orderBy, orderDesc, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EventApi - axios parameter creator
 * @export
 */
export const EventApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new event.
         * @summary Create Event
         * @param {StudyId} studyId 
         * @param {Event} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventStudyStudyIdEventPost: async (studyId: StudyId, event: Event, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('createEventStudyStudyIdEventPost', 'studyId', studyId)
            // verify required parameter 'event' is not null or undefined
            assertParamExists('createEventStudyStudyIdEventPost', 'event', event)
            const localVarPath = `/study/{study_id}/event`
                .replace(`{${"study_id"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(event, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete existing event - Not Yet Implented
         * @summary Delete Event
         * @param {string} eventId 
         * @param {StudyId} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventStudyStudyIdEventEventIdDelete: async (eventId: string, studyId: StudyId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('deleteEventStudyStudyIdEventEventIdDelete', 'eventId', eventId)
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('deleteEventStudyStudyIdEventEventIdDelete', 'studyId', studyId)
            const localVarPath = `/study/{study_id}/event/{event_id}`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"study_id"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all studies the user has access too.
         * @summary List Events
         * @param {StudyId} studyId 
         * @param {boolean} [hideCompleted] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [orderBy] 
         * @param {boolean} [orderDesc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventsStudyStudyIdEventGet: async (studyId: StudyId, hideCompleted?: boolean, offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('listEventsStudyStudyIdEventGet', 'studyId', studyId)
            const localVarPath = `/study/{study_id}/event`
                .replace(`{${"study_id"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (hideCompleted !== undefined) {
                localVarQueryParameter['hide_completed'] = hideCompleted;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderDesc !== undefined) {
                localVarQueryParameter['order_desc'] = orderDesc;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update existing event
         * @summary Update Event
         * @param {string} eventId 
         * @param {StudyId} studyId 
         * @param {EventUpdate} eventUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventStudyStudyIdEventEventIdPatch: async (eventId: string, studyId: StudyId, eventUpdate: EventUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateEventStudyStudyIdEventEventIdPatch', 'eventId', eventId)
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('updateEventStudyStudyIdEventEventIdPatch', 'studyId', studyId)
            // verify required parameter 'eventUpdate' is not null or undefined
            assertParamExists('updateEventStudyStudyIdEventEventIdPatch', 'eventUpdate', eventUpdate)
            const localVarPath = `/study/{study_id}/event/{event_id}`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"study_id"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eventUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventApi - functional programming interface
 * @export
 */
export const EventApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new event.
         * @summary Create Event
         * @param {StudyId} studyId 
         * @param {Event} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEventStudyStudyIdEventPost(studyId: StudyId, event: Event, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEventStudyStudyIdEventPost(studyId, event, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventApi.createEventStudyStudyIdEventPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete existing event - Not Yet Implented
         * @summary Delete Event
         * @param {string} eventId 
         * @param {StudyId} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEventStudyStudyIdEventEventIdDelete(eventId: string, studyId: StudyId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEventStudyStudyIdEventEventIdDelete(eventId, studyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventApi.deleteEventStudyStudyIdEventEventIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all studies the user has access too.
         * @summary List Events
         * @param {StudyId} studyId 
         * @param {boolean} [hideCompleted] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [orderBy] 
         * @param {boolean} [orderDesc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEventsStudyStudyIdEventGet(studyId: StudyId, hideCompleted?: boolean, offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEventsStudyStudyIdEventGet(studyId, hideCompleted, offset, limit, orderBy, orderDesc, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventApi.listEventsStudyStudyIdEventGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update existing event
         * @summary Update Event
         * @param {string} eventId 
         * @param {StudyId} studyId 
         * @param {EventUpdate} eventUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEventStudyStudyIdEventEventIdPatch(eventId: string, studyId: StudyId, eventUpdate: EventUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEventStudyStudyIdEventEventIdPatch(eventId, studyId, eventUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventApi.updateEventStudyStudyIdEventEventIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EventApi - factory interface
 * @export
 */
export const EventApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventApiFp(configuration)
    return {
        /**
         * Create a new event.
         * @summary Create Event
         * @param {StudyId} studyId 
         * @param {Event} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventStudyStudyIdEventPost(studyId: StudyId, event: Event, options?: any): AxiosPromise<Event> {
            return localVarFp.createEventStudyStudyIdEventPost(studyId, event, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete existing event - Not Yet Implented
         * @summary Delete Event
         * @param {string} eventId 
         * @param {StudyId} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventStudyStudyIdEventEventIdDelete(eventId: string, studyId: StudyId, options?: any): AxiosPromise<void> {
            return localVarFp.deleteEventStudyStudyIdEventEventIdDelete(eventId, studyId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all studies the user has access too.
         * @summary List Events
         * @param {StudyId} studyId 
         * @param {boolean} [hideCompleted] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [orderBy] 
         * @param {boolean} [orderDesc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventsStudyStudyIdEventGet(studyId: StudyId, hideCompleted?: boolean, offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options?: any): AxiosPromise<PaginatedResponseEvent> {
            return localVarFp.listEventsStudyStudyIdEventGet(studyId, hideCompleted, offset, limit, orderBy, orderDesc, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing event
         * @summary Update Event
         * @param {string} eventId 
         * @param {StudyId} studyId 
         * @param {EventUpdate} eventUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventStudyStudyIdEventEventIdPatch(eventId: string, studyId: StudyId, eventUpdate: EventUpdate, options?: any): AxiosPromise<Event> {
            return localVarFp.updateEventStudyStudyIdEventEventIdPatch(eventId, studyId, eventUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventApi - object-oriented interface
 * @export
 * @class EventApi
 * @extends {BaseAPI}
 */
export class EventApi extends BaseAPI {
    /**
     * Create a new event.
     * @summary Create Event
     * @param {StudyId} studyId 
     * @param {Event} event 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public createEventStudyStudyIdEventPost(studyId: StudyId, event: Event, options?: RawAxiosRequestConfig) {
        return EventApiFp(this.configuration).createEventStudyStudyIdEventPost(studyId, event, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete existing event - Not Yet Implented
     * @summary Delete Event
     * @param {string} eventId 
     * @param {StudyId} studyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public deleteEventStudyStudyIdEventEventIdDelete(eventId: string, studyId: StudyId, options?: RawAxiosRequestConfig) {
        return EventApiFp(this.configuration).deleteEventStudyStudyIdEventEventIdDelete(eventId, studyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all studies the user has access too.
     * @summary List Events
     * @param {StudyId} studyId 
     * @param {boolean} [hideCompleted] 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {string} [orderBy] 
     * @param {boolean} [orderDesc] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public listEventsStudyStudyIdEventGet(studyId: StudyId, hideCompleted?: boolean, offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options?: RawAxiosRequestConfig) {
        return EventApiFp(this.configuration).listEventsStudyStudyIdEventGet(studyId, hideCompleted, offset, limit, orderBy, orderDesc, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update existing event
     * @summary Update Event
     * @param {string} eventId 
     * @param {StudyId} studyId 
     * @param {EventUpdate} eventUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public updateEventStudyStudyIdEventEventIdPatch(eventId: string, studyId: StudyId, eventUpdate: EventUpdate, options?: RawAxiosRequestConfig) {
        return EventApiFp(this.configuration).updateEventStudyStudyIdEventEventIdPatch(eventId, studyId, eventUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * IntakeApi - axios parameter creator
 * @export
 */
export const IntakeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create intake record in certain interview. user must have at least \'interviewer\'-permissions on study.
         * @summary Create Intake
         * @param {string} interviewId 
         * @param {StudyId} studyId 
         * @param {IntakeCreate} intakeCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIntakeStudyStudyIdInterviewInterviewIdIntakePost: async (interviewId: string, studyId: StudyId, intakeCreate: IntakeCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'interviewId' is not null or undefined
            assertParamExists('createIntakeStudyStudyIdInterviewInterviewIdIntakePost', 'interviewId', interviewId)
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('createIntakeStudyStudyIdInterviewInterviewIdIntakePost', 'studyId', studyId)
            // verify required parameter 'intakeCreate' is not null or undefined
            assertParamExists('createIntakeStudyStudyIdInterviewInterviewIdIntakePost', 'intakeCreate', intakeCreate)
            const localVarPath = `/study/{study_id}/interview/{interview_id}/intake`
                .replace(`{${"interview_id"}}`, encodeURIComponent(String(interviewId)))
                .replace(`{${"study_id"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(intakeCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update intake record. user must have at least \'interviewer\'-permissions on study.
         * @summary Delete Intake
         * @param {string} interviewId 
         * @param {string} intakeId 
         * @param {StudyId} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIntakeStudyStudyIdInterviewInterviewIdIntakeIntakeIdDelete: async (interviewId: string, intakeId: string, studyId: StudyId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'interviewId' is not null or undefined
            assertParamExists('deleteIntakeStudyStudyIdInterviewInterviewIdIntakeIntakeIdDelete', 'interviewId', interviewId)
            // verify required parameter 'intakeId' is not null or undefined
            assertParamExists('deleteIntakeStudyStudyIdInterviewInterviewIdIntakeIntakeIdDelete', 'intakeId', intakeId)
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('deleteIntakeStudyStudyIdInterviewInterviewIdIntakeIntakeIdDelete', 'studyId', studyId)
            const localVarPath = `/study/{study_id}/interview/{interview_id}/intake/{intake_id}`
                .replace(`{${"interview_id"}}`, encodeURIComponent(String(interviewId)))
                .replace(`{${"intake_id"}}`, encodeURIComponent(String(intakeId)))
                .replace(`{${"study_id"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a certain intake record by it id
         * @summary Get Intake
         * @param {string} interviewId 
         * @param {string} intakeId 
         * @param {StudyId} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntakeStudyStudyIdInterviewInterviewIdIntakeIntakeIdGet: async (interviewId: string, intakeId: string, studyId: StudyId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'interviewId' is not null or undefined
            assertParamExists('getIntakeStudyStudyIdInterviewInterviewIdIntakeIntakeIdGet', 'interviewId', interviewId)
            // verify required parameter 'intakeId' is not null or undefined
            assertParamExists('getIntakeStudyStudyIdInterviewInterviewIdIntakeIntakeIdGet', 'intakeId', intakeId)
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('getIntakeStudyStudyIdInterviewInterviewIdIntakeIntakeIdGet', 'studyId', studyId)
            const localVarPath = `/study/{study_id}/interview/{interview_id}/intake/{intake_id}`
                .replace(`{${"interview_id"}}`, encodeURIComponent(String(interviewId)))
                .replace(`{${"intake_id"}}`, encodeURIComponent(String(intakeId)))
                .replace(`{${"study_id"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all medicine intakes of interview.
         * @summary List All Intakes Of Interview
         * @param {string} interviewId 
         * @param {StudyId} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllIntakesOfInterviewStudyStudyIdInterviewInterviewIdIntakeGet: async (interviewId: string, studyId: StudyId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'interviewId' is not null or undefined
            assertParamExists('listAllIntakesOfInterviewStudyStudyIdInterviewInterviewIdIntakeGet', 'interviewId', interviewId)
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('listAllIntakesOfInterviewStudyStudyIdInterviewInterviewIdIntakeGet', 'studyId', studyId)
            const localVarPath = `/study/{study_id}/interview/{interview_id}/intake`
                .replace(`{${"interview_id"}}`, encodeURIComponent(String(interviewId)))
                .replace(`{${"study_id"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all medicine intakes of one probands last completed interview.
         * @summary List All Intakes Of Last Completed Interview
         * @param {string} probandId 
         * @param {StudyId} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllIntakesOfLastCompletedInterviewStudyStudyIdProbandProbandIdInterviewLastIntakeGet: async (probandId: string, studyId: StudyId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'probandId' is not null or undefined
            assertParamExists('listAllIntakesOfLastCompletedInterviewStudyStudyIdProbandProbandIdInterviewLastIntakeGet', 'probandId', probandId)
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('listAllIntakesOfLastCompletedInterviewStudyStudyIdProbandProbandIdInterviewLastIntakeGet', 'studyId', studyId)
            const localVarPath = `/study/{study_id}/proband/{proband_id}/interview/last/intake`
                .replace(`{${"proband_id"}}`, encodeURIComponent(String(probandId)))
                .replace(`{${"study_id"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all medicine intakes of one probands last completed interview.
         * @summary List All Intakes Of Last Uncompleted Interview
         * @param {string} probandId 
         * @param {StudyId} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllIntakesOfLastUncompletedInterviewStudyStudyIdProbandProbandIdInterviewCurrentIntakeGet: async (probandId: string, studyId: StudyId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'probandId' is not null or undefined
            assertParamExists('listAllIntakesOfLastUncompletedInterviewStudyStudyIdProbandProbandIdInterviewCurrentIntakeGet', 'probandId', probandId)
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('listAllIntakesOfLastUncompletedInterviewStudyStudyIdProbandProbandIdInterviewCurrentIntakeGet', 'studyId', studyId)
            const localVarPath = `/study/{study_id}/proband/{proband_id}/interview/current/intake`
                .replace(`{${"proband_id"}}`, encodeURIComponent(String(probandId)))
                .replace(`{${"study_id"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update intake record. user must have at least \'interviewer\'-permissions on study.
         * @summary Update Intake
         * @param {string} interviewId 
         * @param {string} intakeId 
         * @param {StudyId} studyId 
         * @param {IntakeUpdate} intakeUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIntakeStudyStudyIdInterviewInterviewIdIntakeIntakeIdPatch: async (interviewId: string, intakeId: string, studyId: StudyId, intakeUpdate: IntakeUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'interviewId' is not null or undefined
            assertParamExists('updateIntakeStudyStudyIdInterviewInterviewIdIntakeIntakeIdPatch', 'interviewId', interviewId)
            // verify required parameter 'intakeId' is not null or undefined
            assertParamExists('updateIntakeStudyStudyIdInterviewInterviewIdIntakeIntakeIdPatch', 'intakeId', intakeId)
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('updateIntakeStudyStudyIdInterviewInterviewIdIntakeIntakeIdPatch', 'studyId', studyId)
            // verify required parameter 'intakeUpdate' is not null or undefined
            assertParamExists('updateIntakeStudyStudyIdInterviewInterviewIdIntakeIntakeIdPatch', 'intakeUpdate', intakeUpdate)
            const localVarPath = `/study/{study_id}/interview/{interview_id}/intake/{intake_id}`
                .replace(`{${"interview_id"}}`, encodeURIComponent(String(interviewId)))
                .replace(`{${"intake_id"}}`, encodeURIComponent(String(intakeId)))
                .replace(`{${"study_id"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(intakeUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IntakeApi - functional programming interface
 * @export
 */
export const IntakeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IntakeApiAxiosParamCreator(configuration)
    return {
        /**
         * Create intake record in certain interview. user must have at least \'interviewer\'-permissions on study.
         * @summary Create Intake
         * @param {string} interviewId 
         * @param {StudyId} studyId 
         * @param {IntakeCreate} intakeCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createIntakeStudyStudyIdInterviewInterviewIdIntakePost(interviewId: string, studyId: StudyId, intakeCreate: IntakeCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Intake>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createIntakeStudyStudyIdInterviewInterviewIdIntakePost(interviewId, studyId, intakeCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntakeApi.createIntakeStudyStudyIdInterviewInterviewIdIntakePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update intake record. user must have at least \'interviewer\'-permissions on study.
         * @summary Delete Intake
         * @param {string} interviewId 
         * @param {string} intakeId 
         * @param {StudyId} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteIntakeStudyStudyIdInterviewInterviewIdIntakeIntakeIdDelete(interviewId: string, intakeId: string, studyId: StudyId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Intake>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteIntakeStudyStudyIdInterviewInterviewIdIntakeIntakeIdDelete(interviewId, intakeId, studyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntakeApi.deleteIntakeStudyStudyIdInterviewInterviewIdIntakeIntakeIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a certain intake record by it id
         * @summary Get Intake
         * @param {string} interviewId 
         * @param {string} intakeId 
         * @param {StudyId} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIntakeStudyStudyIdInterviewInterviewIdIntakeIntakeIdGet(interviewId: string, intakeId: string, studyId: StudyId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Intake>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIntakeStudyStudyIdInterviewInterviewIdIntakeIntakeIdGet(interviewId, intakeId, studyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntakeApi.getIntakeStudyStudyIdInterviewInterviewIdIntakeIntakeIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all medicine intakes of interview.
         * @summary List All Intakes Of Interview
         * @param {string} interviewId 
         * @param {StudyId} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllIntakesOfInterviewStudyStudyIdInterviewInterviewIdIntakeGet(interviewId: string, studyId: StudyId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Intake>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllIntakesOfInterviewStudyStudyIdInterviewInterviewIdIntakeGet(interviewId, studyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntakeApi.listAllIntakesOfInterviewStudyStudyIdInterviewInterviewIdIntakeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all medicine intakes of one probands last completed interview.
         * @summary List All Intakes Of Last Completed Interview
         * @param {string} probandId 
         * @param {StudyId} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllIntakesOfLastCompletedInterviewStudyStudyIdProbandProbandIdInterviewLastIntakeGet(probandId: string, studyId: StudyId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Intake>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllIntakesOfLastCompletedInterviewStudyStudyIdProbandProbandIdInterviewLastIntakeGet(probandId, studyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntakeApi.listAllIntakesOfLastCompletedInterviewStudyStudyIdProbandProbandIdInterviewLastIntakeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all medicine intakes of one probands last completed interview.
         * @summary List All Intakes Of Last Uncompleted Interview
         * @param {string} probandId 
         * @param {StudyId} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllIntakesOfLastUncompletedInterviewStudyStudyIdProbandProbandIdInterviewCurrentIntakeGet(probandId: string, studyId: StudyId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Intake>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllIntakesOfLastUncompletedInterviewStudyStudyIdProbandProbandIdInterviewCurrentIntakeGet(probandId, studyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntakeApi.listAllIntakesOfLastUncompletedInterviewStudyStudyIdProbandProbandIdInterviewCurrentIntakeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update intake record. user must have at least \'interviewer\'-permissions on study.
         * @summary Update Intake
         * @param {string} interviewId 
         * @param {string} intakeId 
         * @param {StudyId} studyId 
         * @param {IntakeUpdate} intakeUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateIntakeStudyStudyIdInterviewInterviewIdIntakeIntakeIdPatch(interviewId: string, intakeId: string, studyId: StudyId, intakeUpdate: IntakeUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Intake>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateIntakeStudyStudyIdInterviewInterviewIdIntakeIntakeIdPatch(interviewId, intakeId, studyId, intakeUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntakeApi.updateIntakeStudyStudyIdInterviewInterviewIdIntakeIntakeIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IntakeApi - factory interface
 * @export
 */
export const IntakeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IntakeApiFp(configuration)
    return {
        /**
         * Create intake record in certain interview. user must have at least \'interviewer\'-permissions on study.
         * @summary Create Intake
         * @param {string} interviewId 
         * @param {StudyId} studyId 
         * @param {IntakeCreate} intakeCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIntakeStudyStudyIdInterviewInterviewIdIntakePost(interviewId: string, studyId: StudyId, intakeCreate: IntakeCreate, options?: any): AxiosPromise<Array<Intake>> {
            return localVarFp.createIntakeStudyStudyIdInterviewInterviewIdIntakePost(interviewId, studyId, intakeCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Update intake record. user must have at least \'interviewer\'-permissions on study.
         * @summary Delete Intake
         * @param {string} interviewId 
         * @param {string} intakeId 
         * @param {StudyId} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIntakeStudyStudyIdInterviewInterviewIdIntakeIntakeIdDelete(interviewId: string, intakeId: string, studyId: StudyId, options?: any): AxiosPromise<Array<Intake>> {
            return localVarFp.deleteIntakeStudyStudyIdInterviewInterviewIdIntakeIntakeIdDelete(interviewId, intakeId, studyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a certain intake record by it id
         * @summary Get Intake
         * @param {string} interviewId 
         * @param {string} intakeId 
         * @param {StudyId} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntakeStudyStudyIdInterviewInterviewIdIntakeIntakeIdGet(interviewId: string, intakeId: string, studyId: StudyId, options?: any): AxiosPromise<Intake> {
            return localVarFp.getIntakeStudyStudyIdInterviewInterviewIdIntakeIntakeIdGet(interviewId, intakeId, studyId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all medicine intakes of interview.
         * @summary List All Intakes Of Interview
         * @param {string} interviewId 
         * @param {StudyId} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllIntakesOfInterviewStudyStudyIdInterviewInterviewIdIntakeGet(interviewId: string, studyId: StudyId, options?: any): AxiosPromise<Array<Intake>> {
            return localVarFp.listAllIntakesOfInterviewStudyStudyIdInterviewInterviewIdIntakeGet(interviewId, studyId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all medicine intakes of one probands last completed interview.
         * @summary List All Intakes Of Last Completed Interview
         * @param {string} probandId 
         * @param {StudyId} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllIntakesOfLastCompletedInterviewStudyStudyIdProbandProbandIdInterviewLastIntakeGet(probandId: string, studyId: StudyId, options?: any): AxiosPromise<Array<Intake>> {
            return localVarFp.listAllIntakesOfLastCompletedInterviewStudyStudyIdProbandProbandIdInterviewLastIntakeGet(probandId, studyId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all medicine intakes of one probands last completed interview.
         * @summary List All Intakes Of Last Uncompleted Interview
         * @param {string} probandId 
         * @param {StudyId} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllIntakesOfLastUncompletedInterviewStudyStudyIdProbandProbandIdInterviewCurrentIntakeGet(probandId: string, studyId: StudyId, options?: any): AxiosPromise<Array<Intake>> {
            return localVarFp.listAllIntakesOfLastUncompletedInterviewStudyStudyIdProbandProbandIdInterviewCurrentIntakeGet(probandId, studyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update intake record. user must have at least \'interviewer\'-permissions on study.
         * @summary Update Intake
         * @param {string} interviewId 
         * @param {string} intakeId 
         * @param {StudyId} studyId 
         * @param {IntakeUpdate} intakeUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIntakeStudyStudyIdInterviewInterviewIdIntakeIntakeIdPatch(interviewId: string, intakeId: string, studyId: StudyId, intakeUpdate: IntakeUpdate, options?: any): AxiosPromise<Array<Intake>> {
            return localVarFp.updateIntakeStudyStudyIdInterviewInterviewIdIntakeIntakeIdPatch(interviewId, intakeId, studyId, intakeUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IntakeApi - object-oriented interface
 * @export
 * @class IntakeApi
 * @extends {BaseAPI}
 */
export class IntakeApi extends BaseAPI {
    /**
     * Create intake record in certain interview. user must have at least \'interviewer\'-permissions on study.
     * @summary Create Intake
     * @param {string} interviewId 
     * @param {StudyId} studyId 
     * @param {IntakeCreate} intakeCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntakeApi
     */
    public createIntakeStudyStudyIdInterviewInterviewIdIntakePost(interviewId: string, studyId: StudyId, intakeCreate: IntakeCreate, options?: RawAxiosRequestConfig) {
        return IntakeApiFp(this.configuration).createIntakeStudyStudyIdInterviewInterviewIdIntakePost(interviewId, studyId, intakeCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update intake record. user must have at least \'interviewer\'-permissions on study.
     * @summary Delete Intake
     * @param {string} interviewId 
     * @param {string} intakeId 
     * @param {StudyId} studyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntakeApi
     */
    public deleteIntakeStudyStudyIdInterviewInterviewIdIntakeIntakeIdDelete(interviewId: string, intakeId: string, studyId: StudyId, options?: RawAxiosRequestConfig) {
        return IntakeApiFp(this.configuration).deleteIntakeStudyStudyIdInterviewInterviewIdIntakeIntakeIdDelete(interviewId, intakeId, studyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a certain intake record by it id
     * @summary Get Intake
     * @param {string} interviewId 
     * @param {string} intakeId 
     * @param {StudyId} studyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntakeApi
     */
    public getIntakeStudyStudyIdInterviewInterviewIdIntakeIntakeIdGet(interviewId: string, intakeId: string, studyId: StudyId, options?: RawAxiosRequestConfig) {
        return IntakeApiFp(this.configuration).getIntakeStudyStudyIdInterviewInterviewIdIntakeIntakeIdGet(interviewId, intakeId, studyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all medicine intakes of interview.
     * @summary List All Intakes Of Interview
     * @param {string} interviewId 
     * @param {StudyId} studyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntakeApi
     */
    public listAllIntakesOfInterviewStudyStudyIdInterviewInterviewIdIntakeGet(interviewId: string, studyId: StudyId, options?: RawAxiosRequestConfig) {
        return IntakeApiFp(this.configuration).listAllIntakesOfInterviewStudyStudyIdInterviewInterviewIdIntakeGet(interviewId, studyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all medicine intakes of one probands last completed interview.
     * @summary List All Intakes Of Last Completed Interview
     * @param {string} probandId 
     * @param {StudyId} studyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntakeApi
     */
    public listAllIntakesOfLastCompletedInterviewStudyStudyIdProbandProbandIdInterviewLastIntakeGet(probandId: string, studyId: StudyId, options?: RawAxiosRequestConfig) {
        return IntakeApiFp(this.configuration).listAllIntakesOfLastCompletedInterviewStudyStudyIdProbandProbandIdInterviewLastIntakeGet(probandId, studyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all medicine intakes of one probands last completed interview.
     * @summary List All Intakes Of Last Uncompleted Interview
     * @param {string} probandId 
     * @param {StudyId} studyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntakeApi
     */
    public listAllIntakesOfLastUncompletedInterviewStudyStudyIdProbandProbandIdInterviewCurrentIntakeGet(probandId: string, studyId: StudyId, options?: RawAxiosRequestConfig) {
        return IntakeApiFp(this.configuration).listAllIntakesOfLastUncompletedInterviewStudyStudyIdProbandProbandIdInterviewCurrentIntakeGet(probandId, studyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update intake record. user must have at least \'interviewer\'-permissions on study.
     * @summary Update Intake
     * @param {string} interviewId 
     * @param {string} intakeId 
     * @param {StudyId} studyId 
     * @param {IntakeUpdate} intakeUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntakeApi
     */
    public updateIntakeStudyStudyIdInterviewInterviewIdIntakeIntakeIdPatch(interviewId: string, intakeId: string, studyId: StudyId, intakeUpdate: IntakeUpdate, options?: RawAxiosRequestConfig) {
        return IntakeApiFp(this.configuration).updateIntakeStudyStudyIdInterviewInterviewIdIntakeIntakeIdPatch(interviewId, intakeId, studyId, intakeUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InterviewApi - axios parameter creator
 * @export
 */
export const InterviewApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new interview
         * @summary Create Interview
         * @param {string} eventId 
         * @param {StudyId} studyId 
         * @param {InterviewCreate} interviewCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInterviewStudyStudyIdEventEventIdInterviewPost: async (eventId: string, studyId: StudyId, interviewCreate: InterviewCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createInterviewStudyStudyIdEventEventIdInterviewPost', 'eventId', eventId)
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('createInterviewStudyStudyIdEventEventIdInterviewPost', 'studyId', studyId)
            // verify required parameter 'interviewCreate' is not null or undefined
            assertParamExists('createInterviewStudyStudyIdEventEventIdInterviewPost', 'interviewCreate', interviewCreate)
            const localVarPath = `/study/{study_id}/event/{event_id}/interview`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"study_id"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(interviewCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete existing interview - Not Yet Implented
         * @summary Delete Interview
         * @param {string} interviewId 
         * @param {string} eventId 
         * @param {StudyId} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInterviewStudyStudyIdEventEventIdInterviewInterviewIdDelete: async (interviewId: string, eventId: string, studyId: StudyId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'interviewId' is not null or undefined
            assertParamExists('deleteInterviewStudyStudyIdEventEventIdInterviewInterviewIdDelete', 'interviewId', interviewId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('deleteInterviewStudyStudyIdEventEventIdInterviewInterviewIdDelete', 'eventId', eventId)
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('deleteInterviewStudyStudyIdEventEventIdInterviewInterviewIdDelete', 'studyId', studyId)
            const localVarPath = `/study/{study_id}/event/{event_id}/interview/{interview_id}`
                .replace(`{${"interview_id"}}`, encodeURIComponent(String(interviewId)))
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"study_id"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a certain interview by its id.
         * @summary Get Interview
         * @param {string} eventId 
         * @param {string} interviewId 
         * @param {StudyId} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterviewStudyStudyIdEventEventIdInterviewInterviewIdGet: async (eventId: string, interviewId: string, studyId: StudyId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getInterviewStudyStudyIdEventEventIdInterviewInterviewIdGet', 'eventId', eventId)
            // verify required parameter 'interviewId' is not null or undefined
            assertParamExists('getInterviewStudyStudyIdEventEventIdInterviewInterviewIdGet', 'interviewId', interviewId)
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('getInterviewStudyStudyIdEventEventIdInterviewInterviewIdGet', 'studyId', studyId)
            const localVarPath = `/study/{study_id}/event/{event_id}/interview/{interview_id}`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"interview_id"}}`, encodeURIComponent(String(interviewId)))
                .replace(`{${"study_id"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the last completed interview of proband.
         * @summary Get Last Completed Interview
         * @param {string} probandId 
         * @param {StudyId} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastCompletedInterviewStudyStudyIdProbandProbandIdInterviewLastGet: async (probandId: string, studyId: StudyId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'probandId' is not null or undefined
            assertParamExists('getLastCompletedInterviewStudyStudyIdProbandProbandIdInterviewLastGet', 'probandId', probandId)
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('getLastCompletedInterviewStudyStudyIdProbandProbandIdInterviewLastGet', 'studyId', studyId)
            const localVarPath = `/study/{study_id}/proband/{proband_id}/interview/last`
                .replace(`{${"proband_id"}}`, encodeURIComponent(String(probandId)))
                .replace(`{${"study_id"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the latest non completed interview of proband.
         * @summary Get Last Non Completed Interview
         * @param {string} probandId 
         * @param {StudyId} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastNonCompletedInterviewStudyStudyIdProbandProbandIdInterviewCurrentGet: async (probandId: string, studyId: StudyId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'probandId' is not null or undefined
            assertParamExists('getLastNonCompletedInterviewStudyStudyIdProbandProbandIdInterviewCurrentGet', 'probandId', probandId)
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('getLastNonCompletedInterviewStudyStudyIdProbandProbandIdInterviewCurrentGet', 'studyId', studyId)
            const localVarPath = `/study/{study_id}/proband/{proband_id}/interview/current`
                .replace(`{${"proband_id"}}`, encodeURIComponent(String(probandId)))
                .replace(`{${"study_id"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all interviews of one study.
         * @summary List All Interviews Of Study
         * @param {StudyId} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllInterviewsOfStudyStudyStudyIdInterviewGet: async (studyId: StudyId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('listAllInterviewsOfStudyStudyStudyIdInterviewGet', 'studyId', studyId)
            const localVarPath = `/study/{study_id}/interview`
                .replace(`{${"study_id"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all interviews of an event.
         * @summary List Interviews By Study Event
         * @param {string} eventId 
         * @param {StudyId} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInterviewsByStudyEventStudyStudyIdEventEventIdInterviewGet: async (eventId: string, studyId: StudyId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('listInterviewsByStudyEventStudyStudyIdEventEventIdInterviewGet', 'eventId', eventId)
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('listInterviewsByStudyEventStudyStudyIdEventEventIdInterviewGet', 'studyId', studyId)
            const localVarPath = `/study/{study_id}/event/{event_id}/interview`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"study_id"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all interviews of one proband.
         * @summary List Interviews Of Proband
         * @param {string} probandId 
         * @param {StudyId} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInterviewsOfProbandStudyStudyIdProbandProbandIdInterviewGet: async (probandId: string, studyId: StudyId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'probandId' is not null or undefined
            assertParamExists('listInterviewsOfProbandStudyStudyIdProbandProbandIdInterviewGet', 'probandId', probandId)
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('listInterviewsOfProbandStudyStudyIdProbandProbandIdInterviewGet', 'studyId', studyId)
            const localVarPath = `/study/{study_id}/proband/{proband_id}/interview`
                .replace(`{${"proband_id"}}`, encodeURIComponent(String(probandId)))
                .replace(`{${"study_id"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update existing interview
         * @summary Update Interview
         * @param {string} interviewId 
         * @param {string} eventId 
         * @param {StudyId} studyId 
         * @param {InterviewUpdate} interviewUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInterviewStudyStudyIdEventEventIdInterviewInterviewIdPatch: async (interviewId: string, eventId: string, studyId: StudyId, interviewUpdate: InterviewUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'interviewId' is not null or undefined
            assertParamExists('updateInterviewStudyStudyIdEventEventIdInterviewInterviewIdPatch', 'interviewId', interviewId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateInterviewStudyStudyIdEventEventIdInterviewInterviewIdPatch', 'eventId', eventId)
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('updateInterviewStudyStudyIdEventEventIdInterviewInterviewIdPatch', 'studyId', studyId)
            // verify required parameter 'interviewUpdate' is not null or undefined
            assertParamExists('updateInterviewStudyStudyIdEventEventIdInterviewInterviewIdPatch', 'interviewUpdate', interviewUpdate)
            const localVarPath = `/study/{study_id}/event/{event_id}/interview/{interview_id}`
                .replace(`{${"interview_id"}}`, encodeURIComponent(String(interviewId)))
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"study_id"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(interviewUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InterviewApi - functional programming interface
 * @export
 */
export const InterviewApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InterviewApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new interview
         * @summary Create Interview
         * @param {string} eventId 
         * @param {StudyId} studyId 
         * @param {InterviewCreate} interviewCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInterviewStudyStudyIdEventEventIdInterviewPost(eventId: string, studyId: StudyId, interviewCreate: InterviewCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Interview>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInterviewStudyStudyIdEventEventIdInterviewPost(eventId, studyId, interviewCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterviewApi.createInterviewStudyStudyIdEventEventIdInterviewPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete existing interview - Not Yet Implented
         * @summary Delete Interview
         * @param {string} interviewId 
         * @param {string} eventId 
         * @param {StudyId} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInterviewStudyStudyIdEventEventIdInterviewInterviewIdDelete(interviewId: string, eventId: string, studyId: StudyId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInterviewStudyStudyIdEventEventIdInterviewInterviewIdDelete(interviewId, eventId, studyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterviewApi.deleteInterviewStudyStudyIdEventEventIdInterviewInterviewIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a certain interview by its id.
         * @summary Get Interview
         * @param {string} eventId 
         * @param {string} interviewId 
         * @param {StudyId} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInterviewStudyStudyIdEventEventIdInterviewInterviewIdGet(eventId: string, interviewId: string, studyId: StudyId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Interview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInterviewStudyStudyIdEventEventIdInterviewInterviewIdGet(eventId, interviewId, studyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterviewApi.getInterviewStudyStudyIdEventEventIdInterviewInterviewIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the last completed interview of proband.
         * @summary Get Last Completed Interview
         * @param {string} probandId 
         * @param {StudyId} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLastCompletedInterviewStudyStudyIdProbandProbandIdInterviewLastGet(probandId: string, studyId: StudyId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Interview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLastCompletedInterviewStudyStudyIdProbandProbandIdInterviewLastGet(probandId, studyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterviewApi.getLastCompletedInterviewStudyStudyIdProbandProbandIdInterviewLastGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the latest non completed interview of proband.
         * @summary Get Last Non Completed Interview
         * @param {string} probandId 
         * @param {StudyId} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLastNonCompletedInterviewStudyStudyIdProbandProbandIdInterviewCurrentGet(probandId: string, studyId: StudyId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Interview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLastNonCompletedInterviewStudyStudyIdProbandProbandIdInterviewCurrentGet(probandId, studyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterviewApi.getLastNonCompletedInterviewStudyStudyIdProbandProbandIdInterviewCurrentGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all interviews of one study.
         * @summary List All Interviews Of Study
         * @param {StudyId} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllInterviewsOfStudyStudyStudyIdInterviewGet(studyId: StudyId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Interview>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllInterviewsOfStudyStudyStudyIdInterviewGet(studyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterviewApi.listAllInterviewsOfStudyStudyStudyIdInterviewGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all interviews of an event.
         * @summary List Interviews By Study Event
         * @param {string} eventId 
         * @param {StudyId} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listInterviewsByStudyEventStudyStudyIdEventEventIdInterviewGet(eventId: string, studyId: StudyId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Interview>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listInterviewsByStudyEventStudyStudyIdEventEventIdInterviewGet(eventId, studyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterviewApi.listInterviewsByStudyEventStudyStudyIdEventEventIdInterviewGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all interviews of one proband.
         * @summary List Interviews Of Proband
         * @param {string} probandId 
         * @param {StudyId} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listInterviewsOfProbandStudyStudyIdProbandProbandIdInterviewGet(probandId: string, studyId: StudyId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Interview>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listInterviewsOfProbandStudyStudyIdProbandProbandIdInterviewGet(probandId, studyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterviewApi.listInterviewsOfProbandStudyStudyIdProbandProbandIdInterviewGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update existing interview
         * @summary Update Interview
         * @param {string} interviewId 
         * @param {string} eventId 
         * @param {StudyId} studyId 
         * @param {InterviewUpdate} interviewUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateInterviewStudyStudyIdEventEventIdInterviewInterviewIdPatch(interviewId: string, eventId: string, studyId: StudyId, interviewUpdate: InterviewUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Interview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateInterviewStudyStudyIdEventEventIdInterviewInterviewIdPatch(interviewId, eventId, studyId, interviewUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterviewApi.updateInterviewStudyStudyIdEventEventIdInterviewInterviewIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InterviewApi - factory interface
 * @export
 */
export const InterviewApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InterviewApiFp(configuration)
    return {
        /**
         * Create new interview
         * @summary Create Interview
         * @param {string} eventId 
         * @param {StudyId} studyId 
         * @param {InterviewCreate} interviewCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInterviewStudyStudyIdEventEventIdInterviewPost(eventId: string, studyId: StudyId, interviewCreate: InterviewCreate, options?: any): AxiosPromise<Array<Interview>> {
            return localVarFp.createInterviewStudyStudyIdEventEventIdInterviewPost(eventId, studyId, interviewCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete existing interview - Not Yet Implented
         * @summary Delete Interview
         * @param {string} interviewId 
         * @param {string} eventId 
         * @param {StudyId} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInterviewStudyStudyIdEventEventIdInterviewInterviewIdDelete(interviewId: string, eventId: string, studyId: StudyId, options?: any): AxiosPromise<void> {
            return localVarFp.deleteInterviewStudyStudyIdEventEventIdInterviewInterviewIdDelete(interviewId, eventId, studyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a certain interview by its id.
         * @summary Get Interview
         * @param {string} eventId 
         * @param {string} interviewId 
         * @param {StudyId} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterviewStudyStudyIdEventEventIdInterviewInterviewIdGet(eventId: string, interviewId: string, studyId: StudyId, options?: any): AxiosPromise<Interview> {
            return localVarFp.getInterviewStudyStudyIdEventEventIdInterviewInterviewIdGet(eventId, interviewId, studyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the last completed interview of proband.
         * @summary Get Last Completed Interview
         * @param {string} probandId 
         * @param {StudyId} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastCompletedInterviewStudyStudyIdProbandProbandIdInterviewLastGet(probandId: string, studyId: StudyId, options?: any): AxiosPromise<Interview> {
            return localVarFp.getLastCompletedInterviewStudyStudyIdProbandProbandIdInterviewLastGet(probandId, studyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the latest non completed interview of proband.
         * @summary Get Last Non Completed Interview
         * @param {string} probandId 
         * @param {StudyId} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastNonCompletedInterviewStudyStudyIdProbandProbandIdInterviewCurrentGet(probandId: string, studyId: StudyId, options?: any): AxiosPromise<Interview> {
            return localVarFp.getLastNonCompletedInterviewStudyStudyIdProbandProbandIdInterviewCurrentGet(probandId, studyId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all interviews of one study.
         * @summary List All Interviews Of Study
         * @param {StudyId} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllInterviewsOfStudyStudyStudyIdInterviewGet(studyId: StudyId, options?: any): AxiosPromise<Array<Interview>> {
            return localVarFp.listAllInterviewsOfStudyStudyStudyIdInterviewGet(studyId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all interviews of an event.
         * @summary List Interviews By Study Event
         * @param {string} eventId 
         * @param {StudyId} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInterviewsByStudyEventStudyStudyIdEventEventIdInterviewGet(eventId: string, studyId: StudyId, options?: any): AxiosPromise<Array<Interview>> {
            return localVarFp.listInterviewsByStudyEventStudyStudyIdEventEventIdInterviewGet(eventId, studyId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all interviews of one proband.
         * @summary List Interviews Of Proband
         * @param {string} probandId 
         * @param {StudyId} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInterviewsOfProbandStudyStudyIdProbandProbandIdInterviewGet(probandId: string, studyId: StudyId, options?: any): AxiosPromise<Array<Interview>> {
            return localVarFp.listInterviewsOfProbandStudyStudyIdProbandProbandIdInterviewGet(probandId, studyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing interview
         * @summary Update Interview
         * @param {string} interviewId 
         * @param {string} eventId 
         * @param {StudyId} studyId 
         * @param {InterviewUpdate} interviewUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInterviewStudyStudyIdEventEventIdInterviewInterviewIdPatch(interviewId: string, eventId: string, studyId: StudyId, interviewUpdate: InterviewUpdate, options?: any): AxiosPromise<Interview> {
            return localVarFp.updateInterviewStudyStudyIdEventEventIdInterviewInterviewIdPatch(interviewId, eventId, studyId, interviewUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InterviewApi - object-oriented interface
 * @export
 * @class InterviewApi
 * @extends {BaseAPI}
 */
export class InterviewApi extends BaseAPI {
    /**
     * Create new interview
     * @summary Create Interview
     * @param {string} eventId 
     * @param {StudyId} studyId 
     * @param {InterviewCreate} interviewCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterviewApi
     */
    public createInterviewStudyStudyIdEventEventIdInterviewPost(eventId: string, studyId: StudyId, interviewCreate: InterviewCreate, options?: RawAxiosRequestConfig) {
        return InterviewApiFp(this.configuration).createInterviewStudyStudyIdEventEventIdInterviewPost(eventId, studyId, interviewCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete existing interview - Not Yet Implented
     * @summary Delete Interview
     * @param {string} interviewId 
     * @param {string} eventId 
     * @param {StudyId} studyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterviewApi
     */
    public deleteInterviewStudyStudyIdEventEventIdInterviewInterviewIdDelete(interviewId: string, eventId: string, studyId: StudyId, options?: RawAxiosRequestConfig) {
        return InterviewApiFp(this.configuration).deleteInterviewStudyStudyIdEventEventIdInterviewInterviewIdDelete(interviewId, eventId, studyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a certain interview by its id.
     * @summary Get Interview
     * @param {string} eventId 
     * @param {string} interviewId 
     * @param {StudyId} studyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterviewApi
     */
    public getInterviewStudyStudyIdEventEventIdInterviewInterviewIdGet(eventId: string, interviewId: string, studyId: StudyId, options?: RawAxiosRequestConfig) {
        return InterviewApiFp(this.configuration).getInterviewStudyStudyIdEventEventIdInterviewInterviewIdGet(eventId, interviewId, studyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the last completed interview of proband.
     * @summary Get Last Completed Interview
     * @param {string} probandId 
     * @param {StudyId} studyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterviewApi
     */
    public getLastCompletedInterviewStudyStudyIdProbandProbandIdInterviewLastGet(probandId: string, studyId: StudyId, options?: RawAxiosRequestConfig) {
        return InterviewApiFp(this.configuration).getLastCompletedInterviewStudyStudyIdProbandProbandIdInterviewLastGet(probandId, studyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the latest non completed interview of proband.
     * @summary Get Last Non Completed Interview
     * @param {string} probandId 
     * @param {StudyId} studyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterviewApi
     */
    public getLastNonCompletedInterviewStudyStudyIdProbandProbandIdInterviewCurrentGet(probandId: string, studyId: StudyId, options?: RawAxiosRequestConfig) {
        return InterviewApiFp(this.configuration).getLastNonCompletedInterviewStudyStudyIdProbandProbandIdInterviewCurrentGet(probandId, studyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all interviews of one study.
     * @summary List All Interviews Of Study
     * @param {StudyId} studyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterviewApi
     */
    public listAllInterviewsOfStudyStudyStudyIdInterviewGet(studyId: StudyId, options?: RawAxiosRequestConfig) {
        return InterviewApiFp(this.configuration).listAllInterviewsOfStudyStudyStudyIdInterviewGet(studyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all interviews of an event.
     * @summary List Interviews By Study Event
     * @param {string} eventId 
     * @param {StudyId} studyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterviewApi
     */
    public listInterviewsByStudyEventStudyStudyIdEventEventIdInterviewGet(eventId: string, studyId: StudyId, options?: RawAxiosRequestConfig) {
        return InterviewApiFp(this.configuration).listInterviewsByStudyEventStudyStudyIdEventEventIdInterviewGet(eventId, studyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all interviews of one proband.
     * @summary List Interviews Of Proband
     * @param {string} probandId 
     * @param {StudyId} studyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterviewApi
     */
    public listInterviewsOfProbandStudyStudyIdProbandProbandIdInterviewGet(probandId: string, studyId: StudyId, options?: RawAxiosRequestConfig) {
        return InterviewApiFp(this.configuration).listInterviewsOfProbandStudyStudyIdProbandProbandIdInterviewGet(probandId, studyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update existing interview
     * @summary Update Interview
     * @param {string} interviewId 
     * @param {string} eventId 
     * @param {StudyId} studyId 
     * @param {InterviewUpdate} interviewUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterviewApi
     */
    public updateInterviewStudyStudyIdEventEventIdInterviewInterviewIdPatch(interviewId: string, eventId: string, studyId: StudyId, interviewUpdate: InterviewUpdate, options?: RawAxiosRequestConfig) {
        return InterviewApiFp(this.configuration).updateInterviewStudyStudyIdEventEventIdInterviewInterviewIdPatch(interviewId, eventId, studyId, interviewUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StudyApi - axios parameter creator
 * @export
 */
export const StudyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new study. Needs admin role.
         * @summary Create Study
         * @param {StudyCreate} studyCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStudyStudyPost: async (studyCreate: StudyCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyCreate' is not null or undefined
            assertParamExists('createStudyStudyPost', 'studyCreate', studyCreate)
            const localVarPath = `/study`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(studyCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete existing study - Not Yet Implented
         * @summary Delete Study
         * @param {string} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStudyStudyStudyIdDelete: async (studyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('deleteStudyStudyStudyIdDelete', 'studyId', studyId)
            const localVarPath = `/study/{study_id}`
                .replace(`{${"study_id"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all studies the user has access too.
         * @summary List Studies
         * @param {boolean} [showDeactived] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [orderBy] 
         * @param {boolean} [orderDesc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStudiesStudyGet: async (showDeactived?: boolean, offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/study`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (showDeactived !== undefined) {
                localVarQueryParameter['show_deactived'] = showDeactived;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderDesc !== undefined) {
                localVarQueryParameter['order_desc'] = orderDesc;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update existing study
         * @summary Update Study
         * @param {string} studyId 
         * @param {StudyUpdate} studyUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStudyStudyStudyIdPatch: async (studyId: string, studyUpdate: StudyUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('updateStudyStudyStudyIdPatch', 'studyId', studyId)
            // verify required parameter 'studyUpdate' is not null or undefined
            assertParamExists('updateStudyStudyStudyIdPatch', 'studyUpdate', studyUpdate)
            const localVarPath = `/study/{study_id}`
                .replace(`{${"study_id"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(studyUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StudyApi - functional programming interface
 * @export
 */
export const StudyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StudyApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new study. Needs admin role.
         * @summary Create Study
         * @param {StudyCreate} studyCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStudyStudyPost(studyCreate: StudyCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Study>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStudyStudyPost(studyCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudyApi.createStudyStudyPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete existing study - Not Yet Implented
         * @summary Delete Study
         * @param {string} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteStudyStudyStudyIdDelete(studyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteStudyStudyStudyIdDelete(studyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudyApi.deleteStudyStudyStudyIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all studies the user has access too.
         * @summary List Studies
         * @param {boolean} [showDeactived] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [orderBy] 
         * @param {boolean} [orderDesc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listStudiesStudyGet(showDeactived?: boolean, offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseStudy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listStudiesStudyGet(showDeactived, offset, limit, orderBy, orderDesc, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudyApi.listStudiesStudyGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update existing study
         * @summary Update Study
         * @param {string} studyId 
         * @param {StudyUpdate} studyUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStudyStudyStudyIdPatch(studyId: string, studyUpdate: StudyUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Study>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStudyStudyStudyIdPatch(studyId, studyUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudyApi.updateStudyStudyStudyIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StudyApi - factory interface
 * @export
 */
export const StudyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StudyApiFp(configuration)
    return {
        /**
         * Create a new study. Needs admin role.
         * @summary Create Study
         * @param {StudyCreate} studyCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStudyStudyPost(studyCreate: StudyCreate, options?: any): AxiosPromise<Study> {
            return localVarFp.createStudyStudyPost(studyCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete existing study - Not Yet Implented
         * @summary Delete Study
         * @param {string} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStudyStudyStudyIdDelete(studyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteStudyStudyStudyIdDelete(studyId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all studies the user has access too.
         * @summary List Studies
         * @param {boolean} [showDeactived] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [orderBy] 
         * @param {boolean} [orderDesc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStudiesStudyGet(showDeactived?: boolean, offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options?: any): AxiosPromise<PaginatedResponseStudy> {
            return localVarFp.listStudiesStudyGet(showDeactived, offset, limit, orderBy, orderDesc, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing study
         * @summary Update Study
         * @param {string} studyId 
         * @param {StudyUpdate} studyUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStudyStudyStudyIdPatch(studyId: string, studyUpdate: StudyUpdate, options?: any): AxiosPromise<Study> {
            return localVarFp.updateStudyStudyStudyIdPatch(studyId, studyUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StudyApi - object-oriented interface
 * @export
 * @class StudyApi
 * @extends {BaseAPI}
 */
export class StudyApi extends BaseAPI {
    /**
     * Create a new study. Needs admin role.
     * @summary Create Study
     * @param {StudyCreate} studyCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudyApi
     */
    public createStudyStudyPost(studyCreate: StudyCreate, options?: RawAxiosRequestConfig) {
        return StudyApiFp(this.configuration).createStudyStudyPost(studyCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete existing study - Not Yet Implented
     * @summary Delete Study
     * @param {string} studyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudyApi
     */
    public deleteStudyStudyStudyIdDelete(studyId: string, options?: RawAxiosRequestConfig) {
        return StudyApiFp(this.configuration).deleteStudyStudyStudyIdDelete(studyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all studies the user has access too.
     * @summary List Studies
     * @param {boolean} [showDeactived] 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {string} [orderBy] 
     * @param {boolean} [orderDesc] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudyApi
     */
    public listStudiesStudyGet(showDeactived?: boolean, offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options?: RawAxiosRequestConfig) {
        return StudyApiFp(this.configuration).listStudiesStudyGet(showDeactived, offset, limit, orderBy, orderDesc, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update existing study
     * @summary Update Study
     * @param {string} studyId 
     * @param {StudyUpdate} studyUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudyApi
     */
    public updateStudyStudyStudyIdPatch(studyId: string, studyUpdate: StudyUpdate, options?: RawAxiosRequestConfig) {
        return StudyApiFp(this.configuration).updateStudyStudyStudyIdPatch(studyId, studyUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StudyPermissionsApi - axios parameter creator
 * @export
 */
export const StudyPermissionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create or update new study permision for a user.
         * @summary Create Or Update Permission
         * @param {string} userId 
         * @param {StudyId} studyId 
         * @param {StudyPermissonUpdate} studyPermissonUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdatePermissionStudyStudyIdPermissionsUserIdPut: async (userId: string, studyId: StudyId, studyPermissonUpdate: StudyPermissonUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('createOrUpdatePermissionStudyStudyIdPermissionsUserIdPut', 'userId', userId)
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('createOrUpdatePermissionStudyStudyIdPermissionsUserIdPut', 'studyId', studyId)
            // verify required parameter 'studyPermissonUpdate' is not null or undefined
            assertParamExists('createOrUpdatePermissionStudyStudyIdPermissionsUserIdPut', 'studyPermissonUpdate', studyPermissonUpdate)
            const localVarPath = `/study/{study_id}/permissions/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"study_id"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(studyPermissonUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all medicine intakes of one probands last completed interview.
         * @summary Get Permission Details
         * @param {string} permissionId 
         * @param {StudyId} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionDetailsStudyStudyIdPermissionsPermissionIdGet: async (permissionId: string, studyId: StudyId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'permissionId' is not null or undefined
            assertParamExists('getPermissionDetailsStudyStudyIdPermissionsPermissionIdGet', 'permissionId', permissionId)
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('getPermissionDetailsStudyStudyIdPermissionsPermissionIdGet', 'studyId', studyId)
            const localVarPath = `/study/{study_id}/permissions/{permission_id}`
                .replace(`{${"permission_id"}}`, encodeURIComponent(String(permissionId)))
                .replace(`{${"study_id"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all access permissons for a study. User must be system admin, system user manager or study admin to see these.
         * @summary List Study Permissions
         * @param {StudyId} studyId 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [orderBy] 
         * @param {boolean} [orderDesc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStudyPermissionsStudyStudyIdPermissionsGet: async (studyId: StudyId, offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('listStudyPermissionsStudyStudyIdPermissionsGet', 'studyId', studyId)
            const localVarPath = `/study/{study_id}/permissions`
                .replace(`{${"study_id"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderDesc !== undefined) {
                localVarQueryParameter['order_desc'] = orderDesc;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StudyPermissionsApi - functional programming interface
 * @export
 */
export const StudyPermissionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StudyPermissionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create or update new study permision for a user.
         * @summary Create Or Update Permission
         * @param {string} userId 
         * @param {StudyId} studyId 
         * @param {StudyPermissonUpdate} studyPermissonUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrUpdatePermissionStudyStudyIdPermissionsUserIdPut(userId: string, studyId: StudyId, studyPermissonUpdate: StudyPermissonUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudyPermissonUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrUpdatePermissionStudyStudyIdPermissionsUserIdPut(userId, studyId, studyPermissonUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudyPermissionsApi.createOrUpdatePermissionStudyStudyIdPermissionsUserIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all medicine intakes of one probands last completed interview.
         * @summary Get Permission Details
         * @param {string} permissionId 
         * @param {StudyId} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPermissionDetailsStudyStudyIdPermissionsPermissionIdGet(permissionId: string, studyId: StudyId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudyPermisson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPermissionDetailsStudyStudyIdPermissionsPermissionIdGet(permissionId, studyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudyPermissionsApi.getPermissionDetailsStudyStudyIdPermissionsPermissionIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all access permissons for a study. User must be system admin, system user manager or study admin to see these.
         * @summary List Study Permissions
         * @param {StudyId} studyId 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [orderBy] 
         * @param {boolean} [orderDesc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listStudyPermissionsStudyStudyIdPermissionsGet(studyId: StudyId, offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseStudyPermissionRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listStudyPermissionsStudyStudyIdPermissionsGet(studyId, offset, limit, orderBy, orderDesc, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudyPermissionsApi.listStudyPermissionsStudyStudyIdPermissionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StudyPermissionsApi - factory interface
 * @export
 */
export const StudyPermissionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StudyPermissionsApiFp(configuration)
    return {
        /**
         * Create or update new study permision for a user.
         * @summary Create Or Update Permission
         * @param {string} userId 
         * @param {StudyId} studyId 
         * @param {StudyPermissonUpdate} studyPermissonUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdatePermissionStudyStudyIdPermissionsUserIdPut(userId: string, studyId: StudyId, studyPermissonUpdate: StudyPermissonUpdate, options?: any): AxiosPromise<StudyPermissonUpdate> {
            return localVarFp.createOrUpdatePermissionStudyStudyIdPermissionsUserIdPut(userId, studyId, studyPermissonUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * List all medicine intakes of one probands last completed interview.
         * @summary Get Permission Details
         * @param {string} permissionId 
         * @param {StudyId} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionDetailsStudyStudyIdPermissionsPermissionIdGet(permissionId: string, studyId: StudyId, options?: any): AxiosPromise<StudyPermisson> {
            return localVarFp.getPermissionDetailsStudyStudyIdPermissionsPermissionIdGet(permissionId, studyId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all access permissons for a study. User must be system admin, system user manager or study admin to see these.
         * @summary List Study Permissions
         * @param {StudyId} studyId 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [orderBy] 
         * @param {boolean} [orderDesc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStudyPermissionsStudyStudyIdPermissionsGet(studyId: StudyId, offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options?: any): AxiosPromise<PaginatedResponseStudyPermissionRead> {
            return localVarFp.listStudyPermissionsStudyStudyIdPermissionsGet(studyId, offset, limit, orderBy, orderDesc, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StudyPermissionsApi - object-oriented interface
 * @export
 * @class StudyPermissionsApi
 * @extends {BaseAPI}
 */
export class StudyPermissionsApi extends BaseAPI {
    /**
     * Create or update new study permision for a user.
     * @summary Create Or Update Permission
     * @param {string} userId 
     * @param {StudyId} studyId 
     * @param {StudyPermissonUpdate} studyPermissonUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudyPermissionsApi
     */
    public createOrUpdatePermissionStudyStudyIdPermissionsUserIdPut(userId: string, studyId: StudyId, studyPermissonUpdate: StudyPermissonUpdate, options?: RawAxiosRequestConfig) {
        return StudyPermissionsApiFp(this.configuration).createOrUpdatePermissionStudyStudyIdPermissionsUserIdPut(userId, studyId, studyPermissonUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all medicine intakes of one probands last completed interview.
     * @summary Get Permission Details
     * @param {string} permissionId 
     * @param {StudyId} studyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudyPermissionsApi
     */
    public getPermissionDetailsStudyStudyIdPermissionsPermissionIdGet(permissionId: string, studyId: StudyId, options?: RawAxiosRequestConfig) {
        return StudyPermissionsApiFp(this.configuration).getPermissionDetailsStudyStudyIdPermissionsPermissionIdGet(permissionId, studyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all access permissons for a study. User must be system admin, system user manager or study admin to see these.
     * @summary List Study Permissions
     * @param {StudyId} studyId 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {string} [orderBy] 
     * @param {boolean} [orderDesc] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudyPermissionsApi
     */
    public listStudyPermissionsStudyStudyIdPermissionsGet(studyId: StudyId, offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options?: RawAxiosRequestConfig) {
        return StudyPermissionsApiFp(this.configuration).listStudyPermissionsStudyStudyIdPermissionsGet(studyId, offset, limit, orderBy, orderDesc, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new user in the local user database. Needs admin or user-manager role.
         * @summary Create Local User
         * @param {UserCreate} userCreate 
         * @param {string} [userPassword] The password for the created user. If non is defined the user will be created but not able to login until an admin user defines a password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLocalUserUserPost: async (userCreate: UserCreate, userPassword?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreate' is not null or undefined
            assertParamExists('createLocalUserUserPost', 'userCreate', userCreate)
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (userPassword !== undefined) {
                localVarQueryParameter['user_password'] = userPassword;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get account data from the current user
         * @summary Get Myself
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyselfUserMeGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get account data from a user by its id. Needs admin or user-manager role.
         * @summary Get User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserUserUserIdGet: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserUserUserIdGet', 'userId', userId)
            const localVarPath = `/user/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get account data from a user by its id.  Needs admin or user-manager role.
         * @summary List Users
         * @param {boolean} [inclDeactivated] Also list deactivated users.
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [orderBy] 
         * @param {boolean} [orderDesc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersUserGet: async (inclDeactivated?: boolean, offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (inclDeactivated !== undefined) {
                localVarQueryParameter['incl_deactivated'] = inclDeactivated;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderDesc !== undefined) {
                localVarQueryParameter['order_desc'] = orderDesc;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set my password if i am a \'local\' user. If my account was provisioned via an external OpenID Connect provider this does nothing except the return value will be `false`.
         * @summary Set My Password
         * @param {string} [oldPassword] 
         * @param {string} [newPassword] 
         * @param {string} [newPasswordRepeated] For good measure we require the password twice to mitiage typos.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMyPasswordUserMePasswordPut: async (oldPassword?: string, newPassword?: string, newPasswordRepeated?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/me/password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


            if (oldPassword !== undefined) { 
                localVarFormParams.set('old_password', oldPassword as any);
            }
    
            if (newPassword !== undefined) { 
                localVarFormParams.set('new_password', newPassword as any);
            }
    
            if (newPasswordRepeated !== undefined) { 
                localVarFormParams.set('new_password_repeated', newPasswordRepeated as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set a local users password. If the user is provisioned via an external OpenID Connect provider this does nothing except the return value will be `false`.  Needs admin or user-manager role.
         * @summary Set User Password
         * @param {string} userId 
         * @param {string} [newPassword] 
         * @param {string} [newPasswordRepeated] For good measure we require the password twice to mitiage typos.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserPasswordUserUserIdPasswordPut: async (userId: string, newPassword?: string, newPasswordRepeated?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('setUserPasswordUserUserIdPasswordPut', 'userId', userId)
            const localVarPath = `/user/{user_id}/password`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


            if (newPassword !== undefined) { 
                localVarFormParams.set('new_password', newPassword as any);
            }
    
            if (newPasswordRepeated !== undefined) { 
                localVarFormParams.set('new_password_repeated', newPasswordRepeated as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update my user account data.
         * @summary Update Myself
         * @param {UserUpdateByUser} userUpdateByUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMyselfUserMePatch: async (userUpdateByUser: UserUpdateByUser, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userUpdateByUser' is not null or undefined
            assertParamExists('updateMyselfUserMePatch', 'userUpdateByUser', userUpdateByUser)
            const localVarPath = `/user/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdateByUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get account data from a user by its id. Needs admin or user-manager role.
         * @summary Update User
         * @param {string} userId 
         * @param {UserUpdateByAdmin} userUpdateByAdmin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserUserUserIdPatch: async (userId: string, userUpdateByAdmin: UserUpdateByAdmin, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUserUserUserIdPatch', 'userId', userId)
            // verify required parameter 'userUpdateByAdmin' is not null or undefined
            assertParamExists('updateUserUserUserIdPatch', 'userUpdateByAdmin', userUpdateByAdmin)
            const localVarPath = `/user/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdateByAdmin, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new user in the local user database. Needs admin or user-manager role.
         * @summary Create Local User
         * @param {UserCreate} userCreate 
         * @param {string} [userPassword] The password for the created user. If non is defined the user will be created but not able to login until an admin user defines a password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLocalUserUserPost(userCreate: UserCreate, userPassword?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLocalUserUserPost(userCreate, userPassword, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.createLocalUserUserPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get account data from the current user
         * @summary Get Myself
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyselfUserMeGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyselfUserMeGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getMyselfUserMeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get account data from a user by its id. Needs admin or user-manager role.
         * @summary Get User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserUserUserIdGet(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserUserUserIdGet(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUserUserUserIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get account data from a user by its id.  Needs admin or user-manager role.
         * @summary List Users
         * @param {boolean} [inclDeactivated] Also list deactivated users.
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [orderBy] 
         * @param {boolean} [orderDesc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsersUserGet(inclDeactivated?: boolean, offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsersUserGet(inclDeactivated, offset, limit, orderBy, orderDesc, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.listUsersUserGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set my password if i am a \'local\' user. If my account was provisioned via an external OpenID Connect provider this does nothing except the return value will be `false`.
         * @summary Set My Password
         * @param {string} [oldPassword] 
         * @param {string} [newPassword] 
         * @param {string} [newPasswordRepeated] For good measure we require the password twice to mitiage typos.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setMyPasswordUserMePasswordPut(oldPassword?: string, newPassword?: string, newPasswordRepeated?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setMyPasswordUserMePasswordPut(oldPassword, newPassword, newPasswordRepeated, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.setMyPasswordUserMePasswordPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set a local users password. If the user is provisioned via an external OpenID Connect provider this does nothing except the return value will be `false`.  Needs admin or user-manager role.
         * @summary Set User Password
         * @param {string} userId 
         * @param {string} [newPassword] 
         * @param {string} [newPasswordRepeated] For good measure we require the password twice to mitiage typos.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setUserPasswordUserUserIdPasswordPut(userId: string, newPassword?: string, newPasswordRepeated?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setUserPasswordUserUserIdPasswordPut(userId, newPassword, newPasswordRepeated, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.setUserPasswordUserUserIdPasswordPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update my user account data.
         * @summary Update Myself
         * @param {UserUpdateByUser} userUpdateByUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMyselfUserMePatch(userUpdateByUser: UserUpdateByUser, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMyselfUserMePatch(userUpdateByUser, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.updateMyselfUserMePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get account data from a user by its id. Needs admin or user-manager role.
         * @summary Update User
         * @param {string} userId 
         * @param {UserUpdateByAdmin} userUpdateByAdmin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserUserUserIdPatch(userId: string, userUpdateByAdmin: UserUpdateByAdmin, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserUserUserIdPatch(userId, userUpdateByAdmin, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.updateUserUserUserIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Creates a new user in the local user database. Needs admin or user-manager role.
         * @summary Create Local User
         * @param {UserCreate} userCreate 
         * @param {string} [userPassword] The password for the created user. If non is defined the user will be created but not able to login until an admin user defines a password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLocalUserUserPost(userCreate: UserCreate, userPassword?: string, options?: any): AxiosPromise<User> {
            return localVarFp.createLocalUserUserPost(userCreate, userPassword, options).then((request) => request(axios, basePath));
        },
        /**
         * Get account data from the current user
         * @summary Get Myself
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyselfUserMeGet(options?: any): AxiosPromise<User> {
            return localVarFp.getMyselfUserMeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get account data from a user by its id. Needs admin or user-manager role.
         * @summary Get User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserUserUserIdGet(userId: string, options?: any): AxiosPromise<User> {
            return localVarFp.getUserUserUserIdGet(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get account data from a user by its id.  Needs admin or user-manager role.
         * @summary List Users
         * @param {boolean} [inclDeactivated] Also list deactivated users.
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [orderBy] 
         * @param {boolean} [orderDesc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersUserGet(inclDeactivated?: boolean, offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options?: any): AxiosPromise<PaginatedResponseUser> {
            return localVarFp.listUsersUserGet(inclDeactivated, offset, limit, orderBy, orderDesc, options).then((request) => request(axios, basePath));
        },
        /**
         * Set my password if i am a \'local\' user. If my account was provisioned via an external OpenID Connect provider this does nothing except the return value will be `false`.
         * @summary Set My Password
         * @param {string} [oldPassword] 
         * @param {string} [newPassword] 
         * @param {string} [newPasswordRepeated] For good measure we require the password twice to mitiage typos.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMyPasswordUserMePasswordPut(oldPassword?: string, newPassword?: string, newPasswordRepeated?: string, options?: any): AxiosPromise<User> {
            return localVarFp.setMyPasswordUserMePasswordPut(oldPassword, newPassword, newPasswordRepeated, options).then((request) => request(axios, basePath));
        },
        /**
         * Set a local users password. If the user is provisioned via an external OpenID Connect provider this does nothing except the return value will be `false`.  Needs admin or user-manager role.
         * @summary Set User Password
         * @param {string} userId 
         * @param {string} [newPassword] 
         * @param {string} [newPasswordRepeated] For good measure we require the password twice to mitiage typos.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserPasswordUserUserIdPasswordPut(userId: string, newPassword?: string, newPasswordRepeated?: string, options?: any): AxiosPromise<User> {
            return localVarFp.setUserPasswordUserUserIdPasswordPut(userId, newPassword, newPasswordRepeated, options).then((request) => request(axios, basePath));
        },
        /**
         * Update my user account data.
         * @summary Update Myself
         * @param {UserUpdateByUser} userUpdateByUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMyselfUserMePatch(userUpdateByUser: UserUpdateByUser, options?: any): AxiosPromise<User> {
            return localVarFp.updateMyselfUserMePatch(userUpdateByUser, options).then((request) => request(axios, basePath));
        },
        /**
         * Get account data from a user by its id. Needs admin or user-manager role.
         * @summary Update User
         * @param {string} userId 
         * @param {UserUpdateByAdmin} userUpdateByAdmin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserUserUserIdPatch(userId: string, userUpdateByAdmin: UserUpdateByAdmin, options?: any): AxiosPromise<User> {
            return localVarFp.updateUserUserUserIdPatch(userId, userUpdateByAdmin, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Creates a new user in the local user database. Needs admin or user-manager role.
     * @summary Create Local User
     * @param {UserCreate} userCreate 
     * @param {string} [userPassword] The password for the created user. If non is defined the user will be created but not able to login until an admin user defines a password.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createLocalUserUserPost(userCreate: UserCreate, userPassword?: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).createLocalUserUserPost(userCreate, userPassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get account data from the current user
     * @summary Get Myself
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getMyselfUserMeGet(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getMyselfUserMeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get account data from a user by its id. Needs admin or user-manager role.
     * @summary Get User
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserUserUserIdGet(userId: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserUserUserIdGet(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get account data from a user by its id.  Needs admin or user-manager role.
     * @summary List Users
     * @param {boolean} [inclDeactivated] Also list deactivated users.
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {string} [orderBy] 
     * @param {boolean} [orderDesc] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public listUsersUserGet(inclDeactivated?: boolean, offset?: number, limit?: number, orderBy?: string, orderDesc?: boolean, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).listUsersUserGet(inclDeactivated, offset, limit, orderBy, orderDesc, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set my password if i am a \'local\' user. If my account was provisioned via an external OpenID Connect provider this does nothing except the return value will be `false`.
     * @summary Set My Password
     * @param {string} [oldPassword] 
     * @param {string} [newPassword] 
     * @param {string} [newPasswordRepeated] For good measure we require the password twice to mitiage typos.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public setMyPasswordUserMePasswordPut(oldPassword?: string, newPassword?: string, newPasswordRepeated?: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).setMyPasswordUserMePasswordPut(oldPassword, newPassword, newPasswordRepeated, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set a local users password. If the user is provisioned via an external OpenID Connect provider this does nothing except the return value will be `false`.  Needs admin or user-manager role.
     * @summary Set User Password
     * @param {string} userId 
     * @param {string} [newPassword] 
     * @param {string} [newPasswordRepeated] For good measure we require the password twice to mitiage typos.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public setUserPasswordUserUserIdPasswordPut(userId: string, newPassword?: string, newPasswordRepeated?: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).setUserPasswordUserUserIdPasswordPut(userId, newPassword, newPasswordRepeated, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update my user account data.
     * @summary Update Myself
     * @param {UserUpdateByUser} userUpdateByUser 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateMyselfUserMePatch(userUpdateByUser: UserUpdateByUser, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).updateMyselfUserMePatch(userUpdateByUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get account data from a user by its id. Needs admin or user-manager role.
     * @summary Update User
     * @param {string} userId 
     * @param {UserUpdateByAdmin} userUpdateByAdmin 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUserUserUserIdPatch(userId: string, userUpdateByAdmin: UserUpdateByAdmin, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).updateUserUserUserIdPatch(userId, userUpdateByAdmin, options).then((request) => request(this.axios, this.basePath));
    }
}



